<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>KalendÃ¡Å™nÃ­ kalkulÃ¡tor - RozÅ¡Ã­Å™enÃ½</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="KomplexnÃ­ kalendÃ¡Å™nÃ­ kalkulÃ¡tor s astronomickÃ½mi funkcemi - den v tÃ½dnu, fÃ¡ze mÄ›sÃ­ce, sluneÄnÃ­ udÃ¡losti, pozice planet a mnoho dalÅ¡Ã­ho">
    <meta name="theme-color" content="#8B7355">
    <meta name="background-color" content="#4A4A3A">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="KalendÃ¡Å™nÃ­ kalkulÃ¡tor">
    <meta name="msapplication-TileColor" content="#8B7355">
    <meta name="msapplication-config" content="browserconfig.xml">
    
    <!-- âœ… OPRAVENÃ PWA Manifest - externÃ­ soubor mÃ­sto inline base64 -->
    <link rel="manifest" href="manifest.json">
    
    <!-- âœ… OPRAVENÃ‰ Apple Touch ikony - externÃ­ soubory mÃ­sto inline base64 -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152.png">
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.png">
    <link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120.png">
    
    <!-- âœ… OPRAVENÃ‰ Favicon - externÃ­ soubory s PNG fallback -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    
    <!-- Zachovat pÅ¯vodnÃ­ styly -->
    <style>
        /* ... vÅ¡echny pÅ¯vodnÃ­ styly ... */
    </style>
</head><body>
    <!-- Connection status indicator -->
    <div id="connectionStatus" class="connection-status"></div>

    <!-- PWA Install prompt -->
    <div id="installPrompt" class="install-prompt">
        <div class="install-prompt-text">
            ğŸ“± Nainstalujte si KalendÃ¡Å™nÃ­ kalkulÃ¡tor jako aplikaci pro rychlejÅ¡Ã­ pÅ™Ã­stup a offline funkÄnost!
        </div>
        <div class="install-buttons">
            <div class="install-btn" id="installBtn">Nainstalovat</div>
            <div class="dismiss-btn" id="dismissBtn">PozdÄ›ji</div>
        </div>
    </div>

    <div class="container">
        <div class="menu-container">
            <div class="menu-button" id="menuButton">â‹®</div>
            <div class="menu-dropdown" id="menuDropdown">
                <div class="menu-section">
                    <div class="menu-item" id="dayOfWeekMenu">ğŸ“… Den v tÃ½dnu</div>
                    <div class="menu-item" id="versionButton">KalendÃ¡Å™nÃ­ kalkulÃ¡tor v4.0 PWA</div>
                    <div class="menu-item has-submenu" id="calculatorsMenu">ğŸ§® DalÅ¡Ã­ vÃ½poÄty</div>
                    <div class="submenu" id="calculatorsSubmenu">
                        <div class="menu-item" data-calculator="year-finder">ğŸ” HledaÄ rokÅ¯</div>
                        <div class="menu-item" data-calculator="calendar-converter">ğŸ”„ PÅ™evod kalendÃ¡Å™Å¯</div>
                        <div class="menu-item" data-calculator="easter">ğŸ¥š Velikonoce</div>
                        <div class="menu-item" data-calculator="moon-phase">ğŸŒ™ FÃ¡ze MÄ›sÃ­ce</div>
                        <div class="menu-item" data-calculator="date-math">â• KalendÃ¡Å™nÃ­ aritmetika</div>
                    </div>
                    <div class="menu-item has-submenu" id="astronomyMenu">ğŸŒŸ AstronomickÃ© vÃ½poÄty</div>
                    <div class="submenu" id="astronomySubmenu">
                        <div class="menu-item" data-calculator="sun-events">â˜€ï¸ SluneÄnÃ­ udÃ¡losti</div>
                        <div class="menu-item" data-calculator="planet-positions">ğŸª Pozice planet</div>
                        <div class="menu-item" data-calculator="eclipses">ğŸŒ‘ ZatmÄ›nÃ­</div>
                        <div class="menu-item" data-calculator="sidereal-time">â° HvÄ›zdnÃ½ Äas</div>
                    </div>
                </div>
                <div class="menu-section">
                    <div class="menu-section-title">BarevnÃ¡ tÃ©mata</div>
                    <div class="theme-item theme-bronze" data-theme="">
                        <div class="theme-preview"></div>
                        BronzovÃ© (vÃ½chozÃ­)
                    </div>
                    <div class="theme-item theme-blue" data-theme="theme-blue">
                        <div class="theme-preview"></div>
                        ModrÃ©
                    </div>
                    <div class="theme-item theme-green" data-theme="theme-green">
                        <div class="theme-preview"></div>
                        ZelenÃ©
                    </div>
                    <div class="theme-item theme-purple" data-theme="theme-purple">
                        <div class="theme-preview"></div>
                        FialovÃ©
                    </div>
                    <div class="theme-item theme-red" data-theme="theme-red">
                        <div class="theme-preview"></div>
                        ÄŒervenÃ©
                    </div>
                </div>
                <div class="menu-section">
                    <div class="menu-item" data-link="https://claude.ai">Created by Claude AI</div>
                    <div class="menu-item" data-link="https://kalendar.beda.cz/kalendar-rozcestnik">VÃ­ce o kalendÃ¡Å™Ã­ch</div>
                </div>
            </div>
        </div>

        <!-- Day of Week Calculator -->
        <div id="dayOfWeekCalculator" class="calculator-view active">
            <div class="header">
                <h1>ğŸ“… Den v tÃ½dnu</h1>
                <p>ZjistÄ›te den v tÃ½dnu pro jakÃ©koliv datum v historii</p>
            </div>
            <div id="display" class="display">
                <div class="display-text">MÃ­sto pro vÃ½sledek</div>
            </div>
            <div class="input-section">
                <label class="input-label" for="dateInput">Zadejte datum:</label>
                <div class="date-input-container">
                    <input type="text" id="dateInput" class="date-input" placeholder="1.1.1 nebo 15.3.44 nebo 01031989" inputmode="numeric" maxlength="15">
                    <div class="format-hint">FormÃ¡ty: 1.1.1 â€¢ 15.3.44 â€¢ 1989 â€¢ 1/3/1989 â€¢ 01031989</div>
                </div>
            </div>
            <button id="calculateBtn" class="calculate-btn">VypoÄÃ­tat</button>

            <div class="examples">
                <h3>ğŸ’¡ VyzkouÅ¡ejte:</h3>
                <ul>
                    <li data-date="1.1.1">1.1.1 - zaÄÃ¡tek naÅ¡eho letopoÄtu</li>
                    <li data-date="15.3.044">15.3.44 - zavraÅ¾dÄ›nÃ­ Julia Caesara</li>
                    <li data-date="4.10.1582">4.10.1582 - poslednÃ­ den juliÃ¡nskÃ©ho kalendÃ¡Å™e</li>
                    <li data-date="15.10.1582">15.10.1582 - prvnÃ­ den gregoriÃ¡nskÃ©ho kalendÃ¡Å™e</li>
                    <li data-date="8.10.1582">8.10.1582 - neexistujÃ­cÃ­ datum!</li>
                    <li data-date="1.1.2000">1.1.2000 - zaÄÃ¡tek novÃ©ho tisÃ­ciletÃ­</li>
                </ul>
            </div>
        </div>

        <!-- Year Finder Calculator -->
        <div id="yearFinderCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>ğŸ” HledaÄ rokÅ¯</h1>
                <p>NajdÄ›te roky pro urÄitou kombinaci dne, mÄ›sÃ­ce a dne v tÃ½dnu</p>
            </div>
            <div id="yearFinderDisplay" class="display">
                <div class="display-text">Nastavte parametry a zobrazte vyhovujÃ­cÃ­ roky</div>
            </div>
            <div class="input-row">
                <div class="input-col">
                    <label class="input-label">Den v mÄ›sÃ­ci:</label>
                    <input type="number" id="yearFinderDay" class="number-input" placeholder="1-31" min="1" max="31">
                </div>
                <div class="input-col">
                    <label class="input-label">MÄ›sÃ­c:</label>
                    <input type="number" id="yearFinderMonth" class="number-input" placeholder="1-12" min="1" max="12">
                </div>
            </div>
            <div class="input-section">
                <label class="input-label">Den v tÃ½dnu:</label>
                <select id="yearFinderDayOfWeek" class="date-input">
                    <option value="">Vyberte den</option>
                    <option value="1">PondÄ›lÃ­</option>
                    <option value="2">ÃšterÃ½</option>
                    <option value="3">StÅ™eda</option>
                    <option value="4">ÄŒtvrtek</option>
                    <option value="5">PÃ¡tek</option>
                    <option value="6">Sobota</option>
                    <option value="0">NedÄ›le</option>
                </select>
            </div>
            <button id="yearFinderBtn" class="calculate-btn">NajÃ­t roky</button>
        </div>

        <!-- Calendar Converter -->
        <div id="calendarConverterCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>ğŸ”„ PÅ™evod kalendÃ¡Å™Å¯</h1>
                <p>PÅ™evod mezi gregoriÃ¡nskÃ½m a juliÃ¡nskÃ½m kalendÃ¡Å™em</p>
            </div>
            <div id="converterDisplay" class="display">
                <div class="display-text">Zadejte datum pro pÅ™evod mezi kalendÃ¡Å™i</div>
            </div>
            <div class="input-section">
                <label class="input-label">Datum (DD.MM.RRRR):</label>
                <input type="text" id="converterDate" class="date-input" placeholder="15.10.1582" inputmode="numeric">
            </div>
            <div class="input-section">
                <label class="input-label">Typ kalendÃ¡Å™e:</label>
                <select id="converterType" class="date-input">
                    <option value="gregorian">GregoriÃ¡nskÃ½ â†’ JuliÃ¡nskÃ½</option>
                    <option value="julian">JuliÃ¡nskÃ½ â†’ GregoriÃ¡nskÃ½</option>
                </select>
            </div>
            <button id="converterBtn" class="calculate-btn">PÅ™evÃ©st</button>
        </div>

        <!-- Easter Calculator -->
        <div id="easterCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>ğŸ¥š Velikonoce</h1>
                <p>VÃ½poÄet data VelikonoÄnÃ­ nedÄ›le a souvisejÃ­cÃ­ch svÃ¡tkÅ¯</p>
            </div>
            <div id="easterDisplay" class="display">
                <div class="display-text">Zadejte rok pro vÃ½poÄet velikonoÄnÃ­ch svÃ¡tkÅ¯</div>
            </div>
            <div class="input-section">
                <label class="input-label">Rok:</label>
                <input type="number" id="easterYear" class="number-input" placeholder="2025" min="1" max="9999">
            </div>
            <button id="easterBtn" class="calculate-btn">VypoÄÃ­tat Velikonoce</button>
        </div>

        <!-- Moon Phase Calculator -->
        <div id="moonPhaseCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>ğŸŒ™ FÃ¡ze MÄ›sÃ­ce</h1>
                <p>ZjistÄ›te fÃ¡zi MÄ›sÃ­ce pro danÃ© datum</p>
            </div>
            <div id="moonDisplay" class="display">
                <div class="display-text">Zadejte datum pro zjiÅ¡tÄ›nÃ­ fÃ¡ze MÄ›sÃ­ce</div>
            </div>
            <div class="input-section">
                <label class="input-label">Datum (DD.MM.RRRR):</label>
                <input type="text" id="moonDate" class="date-input" placeholder="6.7.2025" inputmode="numeric">
            </div>
            <button id="moonBtn" class="calculate-btn">VypoÄÃ­tat fÃ¡zi</button>
        </div>

        <!-- Date Math Calculator -->
        <div id="dateMathCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>â• KalendÃ¡Å™nÃ­ aritmetika</h1>
                <p>PÅ™iÄÃ­tÃ¡nÃ­/odÄÃ­tÃ¡nÃ­ dnÅ¯ a vÃ½poÄet rozdÃ­lÅ¯ mezi daty</p>
            </div>
            <div id="dateMathDisplay" class="display">
                <div class="display-text">Vyberte typ vÃ½poÄtu a zadejte data</div>
            </div>
            <div class="input-section">
                <label class="input-label">Typ vÃ½poÄtu:</label>
                <select id="mathType" class="date-input">
                    <option value="add">PÅ™iÄÃ­st dny k datu</option>
                    <option value="diff">RozdÃ­l mezi daty</option>
                </select>
            </div>
            <div id="addOperation" class="input-section">
                <div class="input-row">
                    <div class="input-col">
                        <label class="input-label">Datum:</label>
                        <input type="text" id="mathDate1" class="date-input" placeholder="1.1.2025" inputmode="numeric">
                    </div>
                    <div class="input-col">
                        <label class="input-label">Dny (+/-):</label>
                        <input type="number" id="mathDays" class="number-input" placeholder="100">
                    </div>
                </div>
            </div>
            <div id="diffOperation" class="input-section" style="display: none;">
                <div class="input-row">
                    <div class="input-col">
                        <label class="input-label">Od data:</label>
                        <input type="text" id="mathDate2" class="date-input" placeholder="1.1.2025" inputmode="numeric">
                    </div>
                    <div class="input-col">
                        <label class="input-label">Do data:</label>
                        <input type="text" id="mathDate3" class="date-input" placeholder="31.12.2025" inputmode="numeric">
                    </div>
                </div>
            </div>
            <button id="dateMathBtn" class="calculate-btn">VypoÄÃ­tat</button>
        </div>

        <!-- Sun Events Calculator -->
        <div id="sunEventsCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>â˜€ï¸ SluneÄnÃ­ udÃ¡losti</h1>
                <p>VÃ½chod, zÃ¡pad slunce a dÃ©lka dne pro zadanÃ© mÃ­sto</p>
            </div>
            <div id="sunEventsDisplay" class="display">
                <div class="display-text">Zadejte datum a souÅ™adnice pro vÃ½poÄet sluneÄnÃ­ch udÃ¡lostÃ­</div>
            </div>
            <div class="input-section">
                <label class="input-label">Datum (DD.MM.RRRR):</label>
                <input type="text" id="sunEventsDate" class="date-input" placeholder="21.6.2025" inputmode="numeric">
            </div>
            <div class="input-row">
                <div class="input-col">
                    <label class="input-label">ZemÄ›pisnÃ¡ Å¡Ã­Å™ka:</label>
                    <input type="number" id="latitude" class="location-input" placeholder="50.0755" step="0.0001" min="-90" max="90">
                </div>
                <div class="input-col">
                    <label class="input-label">ZemÄ›pisnÃ¡ dÃ©lka:</label>
                    <input type="text" id="longitude" class="location-input" placeholder="14.4378" step="0.0001" min="-180" max="180" inputmode="numeric">
                </div>
            </div>
            <div class="format-hint">Praha: 50.0755, 14.4378 â€¢ Brno: 49.1951, 16.6068<br>ÄŒasy se zobrazÃ­ v mÃ­stnÃ­m ÄasovÃ©m pÃ¡smu (vÄetnÄ› letnÃ­ho Äasu)</div>
            <button id="sunEventsBtn" class="calculate-btn">VypoÄÃ­tat sluneÄnÃ­ udÃ¡losti</button>
        </div>

        <!-- Planet Positions Calculator -->
        <div id="planetPositionsCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>ğŸª Pozice planet</h1>
                <p>HeliocentriskÃ© a geocentrickÃ© pozice planet</p>
            </div>
            <div id="planetDisplay" class="display">
                <div class="display-text">Zadejte datum pro vÃ½poÄet pozic planet</div>
            </div>
            <div class="input-section">
                <label class="input-label">Datum (DD.MM.RRRR):</label>
                <input type="text" id="planetDate" class="date-input" placeholder="1.1.2025" inputmode="numeric">
            </div>
            <div class="input-row">
                <div class="input-col">
                    <label class="input-label">ÄŒas (HH:MM):</label>
                    <input type="time" id="planetTime" class="date-input" value="00:00">
                </div>
                <div class="input-col">
                    <label class="input-label">ÄŒasovÃ© pÃ¡smo:</label>
                    <select id="planetTimezone" class="date-input">
                        <option value="0">UTC (GreenwichskÃ½ Äas)</option>
                        <option value="1" selected>CET (UTC+1 - zimnÃ­ Äas)</option>
                        <option value="2">CEST (UTC+2 - letnÃ­ Äas)</option>
                        <option value="-5">EST (UTC-5 - vÃ½chodnÃ­ USA)</option>
                        <option value="-8">PST (UTC-8 - zÃ¡padnÃ­ USA)</option>
                        <option value="9">JST (UTC+9 - Japonsko)</option>
                    </select>
                </div>
            </div>
            <button id="planetBtn" class="calculate-btn">VypoÄÃ­tat pozice planet</button>
        </div>

        <!-- Eclipses Calculator -->
        <div id="eclipsesCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>ğŸŒ‘ ZatmÄ›nÃ­</h1>
                <p>SluneÄnÃ­ a mÄ›sÃ­ÄnÃ­ zatmÄ›nÃ­ v danÃ©m roce</p>
            </div>
            <div id="eclipsesDisplay" class="display">
                <div class="display-text">Zadejte rok pro vÃ½poÄet zatmÄ›nÃ­</div>
            </div>
            <div class="input-section">
                <label class="input-label">Rok:</label>
                <input type="number" id="eclipsesYear" class="number-input" placeholder="2025" min="1900" max="2100">
            </div>
            <button id="eclipsesBtn" class="calculate-btn">NajÃ­t zatmÄ›nÃ­</button>
        </div>

        <!-- Sidereal Time Calculator -->
        <div id="siderealTimeCalculator" class="calculator-view">
            <div class="back-button" data-back="dayOfWeek">â† ZpÄ›t na hlavnÃ­ menu</div>
            <div class="header">
                <h1>â° HvÄ›zdnÃ½ Äas</h1>
                <p>VÃ½poÄet hvÄ›zdnÃ©ho Äasu pro danÃ© mÃ­sto a Äas</p>
            </div>
            <div id="siderealDisplay" class="display">
                <div class="display-text">Zadejte datum, Äas a zemÄ›pisnou dÃ©lku</div>
            </div>
            <div class="input-section">
                <label class="input-label">Datum (DD.MM.RRRR):</label>
                <input type="text" id="siderealDate" class="date-input" placeholder="1.1.2025" inputmode="numeric">
            </div>
            
            <div class="input-row">
                <div class="input-col">
                    <label class="input-label">ÄŒas (HH:MM):</label>
                    <input type="time" id="siderealTime" class="date-input">
                </div>
                <div class="input-col">
                    <label class="input-label">LetnÃ­ Äas (DST):</label>
                    <select id="siderealDST" class="date-input">
                        <option value="0">ZimnÃ­ Äas (standardnÃ­)</option>
                        <option value="1">LetnÃ­ Äas (+1 hodina)</option>
                    </select>
                </div>
            </div>
            <div class="input-section">
                <label class="input-label">ZemÄ›pisnÃ¡ dÃ©lka:</label>
                <input type="text" id="siderealLongitude" class="location-input" placeholder="14.4378" step="0.0001" min="-180" max="180" inputmode="numeric">
                <div class="format-hint">Praha: 14.4378Â° â€¢ LondÃ½n: -0.1278Â° â€¢ New York: -74.0060Â°<br>ÄŒasovÃ© pÃ¡smo se vypoÄÃ­tÃ¡ automaticky z dÃ©lky (15Â° = 1 hodina)</div>
            </div>
            
            <button id="siderealBtn" class="calculate-btn">VypoÄÃ­tat hvÄ›zdnÃ½ Äas</button>
        </div>
    </div>

<script>
(function() {
    'use strict';
    var isMenuOpen = false;
    var currentCalculator = 'dayOfWeek';
    var hasLocalStorage = false;
    var activeInput = null;
    
    // PWA specific variables
    var deferredPrompt;
    var isInstalled = false;
    
    // Test localStorage availability
    try {
        if (typeof Storage !== 'undefined' && window.localStorage) {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            hasLocalStorage = true;
        }
    } catch (e) {
        hasLocalStorage = false;
    }
    
    // PWA Installation functionality
    function initPWA() {
        // Check if app is already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
            isInstalled = true;
        }
        
        // Listen for install prompt
        window.addEventListener('beforeinstallprompt', function(e) {
            e.preventDefault();
            deferredPrompt = e;
            showInstallPrompt();
        });
        
        // Handle successful installation
        window.addEventListener('appinstalled', function(e) {
            hideInstallPrompt();
            isInstalled = true;
            if (hasLocalStorage) {
                try {
                    localStorage.setItem('pwa-installed', 'true');
                } catch(e) {}
            }
        });
        
        // Check if user has previously dismissed install prompt
        var dismissedInstall = false;
        if (hasLocalStorage) {
            try {
                dismissedInstall = localStorage.getItem('pwa-install-dismissed') === 'true';
            } catch(e) {}
        }
        
        // Show install prompt after delay if not installed and not dismissed
        if (!isInstalled && !dismissedInstall) {
            setTimeout(showInstallPrompt, 30000); // Show after 30 seconds
        }
    }
    
    function showInstallPrompt() {
        if (isInstalled || !deferredPrompt) return;
        
        var installPrompt = document.getElementById('installPrompt');
        if (installPrompt) {
            installPrompt.classList.add('show');
        }
    }
    
    function hideInstallPrompt() {
        var installPrompt = document.getElementById('installPrompt');
        if (installPrompt) {
            installPrompt.classList.remove('show');
        }
    }
    
    function handleInstall() {
        if (!deferredPrompt) return;
        
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then(function(choiceResult) {
            if (choiceResult.outcome === 'accepted') {
                console.log('User accepted the install prompt');
            } else {
                console.log('User dismissed the install prompt');
            }
            deferredPrompt = null;
        });
        
        hideInstallPrompt();
    }
    
    function dismissInstall() {
        hideInstallPrompt();
        if (hasLocalStorage) {
            try {
                localStorage.setItem('pwa-install-dismissed', 'true');
            } catch(e) {}
        }
    }
    
    // Connection status monitoring
    function updateConnectionStatus() {
        var statusElement = document.getElementById('connectionStatus');
        if (!statusElement) return;
        
        if (navigator.onLine) {
            statusElement.textContent = 'ğŸŒ Online - synchronizovÃ¡no';
            statusElement.className = 'connection-status online';
            setTimeout(function() {
                statusElement.classList.remove('online');
            }, 2000);
        } else {
            statusElement.textContent = 'ğŸ“± Offline - plnÄ› funkÄnÃ­';
            statusElement.className = 'connection-status offline';
        }
    }
    
    // Enhanced offline detection
    function setupOfflineHandling() {
        // Check if app is running standalone (installed as PWA)
        var isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                          window.navigator.standalone || 
                          document.referrer.includes('android-app://');
        
        if (isStandalone) {
            // Show persistent offline indicator for installed PWA
            updateConnectionStatus();
        }
        
        // Listen for online/offline events
        window.addEventListener('online', function() {
            updateConnectionStatus();
            console.log('Aplikace je online');
        });
        
        window.addEventListener('offline', function() {
            updateConnectionStatus();
            console.log('Aplikace funguje offline');
        });
        
        // Initial status check
        updateConnectionStatus();
    }
    
    // Theme management
    function getStoredTheme() {
        if (hasLocalStorage) {
            try {
                return localStorage.getItem('selectedTheme') || '';
            } catch (e) {
                return '';
            }
        }
        return '';
    }
    
    function setStoredTheme(theme) {
        if (hasLocalStorage) {
            try {
                localStorage.setItem('selectedTheme', theme);
            } catch (e) {}
        }
    }
    
    // Menu functionality
    function toggleMenu() {
        var dropdown = document.getElementById('menuDropdown');
        if (!dropdown) return;
        
        isMenuOpen = !isMenuOpen;
        if (isMenuOpen) {
            dropdown.classList.add('show');
            dropdown.style.display = 'block';
        } else {
            dropdown.classList.remove('show');
            setTimeout(function() {
                if (!isMenuOpen) dropdown.style.display = 'none';
            }, 300);
        }
    }
    
    function toggleSubmenu(submenuId) {
        var submenu = document.getElementById(submenuId);
        if (!submenu) return;
        
        if (submenu.classList.contains('show')) {
            submenu.classList.remove('show');
        } else {
            submenu.classList.add('show');
        }
    }

    // Calculator switching
    function showCalculator(calculatorType) {
        var calculators = document.querySelectorAll('.calculator-view');
        for (var i = 0; i < calculators.length; i++) {
            calculators[i].classList.remove('active');
        }

        var targetCalculator;
        switch(calculatorType) {
            case 'year-finder':
                targetCalculator = document.getElementById('yearFinderCalculator');
                currentCalculator = 'yearFinder';
                break;
            case 'calendar-converter':
                targetCalculator = document.getElementById('calendarConverterCalculator');
                currentCalculator = 'calendarConverter';
                break;
            case 'easter':
                targetCalculator = document.getElementById('easterCalculator');
                currentCalculator = 'easter';
                break;
            case 'moon-phase':
                targetCalculator = document.getElementById('moonPhaseCalculator');
                currentCalculator = 'moonPhase';
                break;
            case 'date-math':
                targetCalculator = document.getElementById('dateMathCalculator');
                currentCalculator = 'dateMath';
                break;
            case 'sun-events':
                targetCalculator = document.getElementById('sunEventsCalculator');
                currentCalculator = 'sunEvents';
                break;
            case 'planet-positions':
                targetCalculator = document.getElementById('planetPositionsCalculator');
                currentCalculator = 'planetPositions';
                break;
            case 'eclipses':
                targetCalculator = document.getElementById('eclipsesCalculator');
                currentCalculator = 'eclipses';
                break;
            case 'sidereal-time':
                targetCalculator = document.getElementById('siderealTimeCalculator');
                currentCalculator = 'siderealTime';
                break;
            default:
                targetCalculator = document.getElementById('dayOfWeekCalculator');
                currentCalculator = 'dayOfWeek';
        }
        if (targetCalculator) {
            targetCalculator.classList.add('active');
        }
        
        var dropdown = document.getElementById('menuDropdown');
        if (dropdown) {
            dropdown.classList.remove('show');
            dropdown.style.display = 'none';
            isMenuOpen = false;
        }
    }

    function changeTheme(themeName) {
        document.body.className = themeName;
        setStoredTheme(themeName);
        var dropdown = document.getElementById('menuDropdown');
        if (dropdown) {
            dropdown.classList.remove('show');
            dropdown.style.display = 'none';
            isMenuOpen = false;
        }
    }
    
    // Display management
    function getCurrentDisplay() {
        switch(currentCalculator) {
            case 'yearFinder': return document.getElementById('yearFinderDisplay');
            case 'calendarConverter': return document.getElementById('converterDisplay');
            case 'easter': return document.getElementById('easterDisplay');
            case 'moonPhase': return document.getElementById('moonDisplay');
            case 'dateMath': return document.getElementById('dateMathDisplay');
            case 'sunEvents': return document.getElementById('sunEventsDisplay');
            case 'planetPositions': return document.getElementById('planetDisplay');
            case 'eclipses': return document.getElementById('eclipsesDisplay');
            case 'siderealTime': return document.getElementById('siderealDisplay');
            default: return document.getElementById('display');
        }
    }
    
    function showLoading() {
        var display = getCurrentDisplay();
        if (display) {
            display.className = 'display';
            display.innerHTML = '<div class="display-text"><span class="loading"></span>PoÄÃ­tÃ¡m...</div>';
        }
    }
    
    function showResult(result) {
        var display = getCurrentDisplay();
        if (display) {
            display.className = 'display result';
            display.innerHTML = '<div class="display-text">' + result + '</div>';
        }
    }
    
    function showError(error) {
        var display = getCurrentDisplay();
        if (display) {
            display.className = 'display error';
            display.innerHTML = '<div class="display-text">âš ï¸ ' + error + '</div>';
        }
    }
    
    function clearDisplay() {
        var display = getCurrentDisplay();
        if (display) {
            display.className = 'display';
            var defaultText = currentCalculator === 'dayOfWeek' ? 
                'Zadejte datum pro vÃ½poÄet' : 
                'Zadejte parametry pro vÃ½poÄet';
            display.innerHTML = '<div class="display-text">' + defaultText + '</div>';
        }
    }

    function showVersion() {
        var display = getCurrentDisplay();
        if (display) {
            display.className = 'display result';
            var installStatus = isInstalled ? 'ğŸ“± NainstalovÃ¡no jako PWA' : 'ğŸŒ WebovÃ¡ verze';
            var offlineStatus = navigator.onLine ? 'ğŸŒ Online pÅ™ipojenÃ­' : 'ğŸ“± Offline reÅ¾im aktivnÃ­';
            display.innerHTML = '<div class="display-text">ğŸ“… <strong>KalendÃ¡Å™nÃ­ kalkulÃ¡tor v4.0 PWA</strong><br><small>AstronomickÃ© funkce: SluneÄnÃ­ udÃ¡losti â€¢ Pozice planet<br>ZatmÄ›nÃ­ â€¢ HvÄ›zdnÃ½ Äas â€¢ VylepÅ¡enÃ© mÄ›sÃ­ÄnÃ­ fÃ¡ze<br>' + installStatus + ' â€¢ ' + offlineStatus + '<br>âœ… PlnÃ¡ offline funkcionalita â€¢ Service Worker aktivnÃ­</small></div>';
        }
        var dropdown = document.getElementById('menuDropdown');
        if (dropdown) {
            dropdown.classList.remove('show');
            dropdown.style.display = 'none';
            isMenuOpen = false;
        }
    }

    function fillDate(dateString) {
        var dateInput = document.getElementById('dateInput');
        if (dateInput) {
            dateInput.value = dateString;
            clearDisplay();
        }
    }
    
    // Date parsing and validation functions - ZACHOVANÃ‰ PÅ˜ESNÄš
    function parseDate(dateString) {
        try {
            var cleaned = dateString.trim();
            var parts = cleaned.split(/[.\-\/\s]+/);
            
            if (parts.length === 1 && /^\d+$/.test(cleaned)) {
                var num = cleaned;
                if (num.length === 8) {
                    parts = [num.substring(0, 2), num.substring(2, 4), num.substring(4, 8)];
                } else if (num.length === 6) {
                    var year = parseInt(num.substring(4, 6));
                    var fullYear = year >= 50 ? 1900 + year : 2000 + year;
                    parts = [num.substring(0, 2), num.substring(2, 4), fullYear.toString()];
                } else if (num.length === 7) {
                    if (parseInt(num.substring(1, 3)) <= 12) {
                        parts = [num.substring(0, 1), num.substring(1, 3), num.substring(3, 7)];
                    } else {
                        parts = [num.substring(0, 2), num.substring(2, 3), num.substring(3, 7)];
                    }
                } else if (num.length === 5) {
                    if (parseInt(num.substring(1, 3)) <= 12) {
                        var year = parseInt(num.substring(3, 5));
                        var fullYear = year >= 50 ? 1900 + year : 2000 + year;
                        parts = [num.substring(0, 1), num.substring(1, 3), fullYear.toString()];
                    } else {
                        var year = parseInt(num.substring(3, 5));
                        var fullYear = year >= 50 ? 1900 + year : 2000 + year;
                        parts = [num.substring(0, 2), num.substring(2, 3), fullYear.toString()];
                    }
                } else if (num.length === 4) {
                    return { day: 1, month: 1, year: parseInt(num) };
                }
            }
            
            if (parts.length !== 3) return null;

            var day = parseInt(parts[0]);
            var month = parseInt(parts[1]);
            var year = parseInt(parts[2]);

            if (year < 100 && parts[2].length === 2 && (cleaned.indexOf('.') !== -1 || cleaned.indexOf('/') !== -1 || cleaned.indexOf('-') !== -1 || cleaned.indexOf(' ') !== -1)) {
                if (year >= 50) {
                    year += 1900;
                } else {
                    year += 2000;
                }
            }

            if (isNaN(day) || isNaN(month) || isNaN(year)) return null;
            return { day: day, month: month, year: year };
        } catch (e) {
            return null;
        }
    }
    
    function validateDate(day, month, year) {
        if (day < 1 || day > 31) return "Den musÃ­ bÃ½t mezi 1 a 31";
        if (month < 1 || month > 12) return "MÄ›sÃ­c musÃ­ bÃ½t mezi 1 a 12";
        if (year < 1) return "Rok musÃ­ bÃ½t alespoÅˆ 1 (zaÄÃ¡tek naÅ¡eho letopoÄtu)";

        var daysInMonth = [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        if (day > daysInMonth[month - 1]) {
            return month + ". mÄ›sÃ­c mÃ¡ pouze " + daysInMonth[month - 1] + " dnÃ­";
        }
        return null;
    }
    
    function isLeapYear(year) {
        if (year < 1582) {
            return year % 4 === 0;
        } else {
            return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        }
    }
    
    function openLink(url) {
        try {
            if (window.open) {
                window.open(url, '_blank');
            } else {
                window.location.href = url;
            }
        } catch (error) {
            try {
                window.location.href = url;
            } catch (e) {}
        }
        toggleMenu();
    }

    // VÅ ECHNY ALGORITMY ZACHOVANÃ‰ PÅ˜ESNÄš BEZ ZMÄšN
    
    // Day of week calculation (Zeller's congruence)
    function getDayOfWeek(d, m, r) {
        try {
            if (r === 1582 && m === 10 && d >= 5 && d <= 14) {
                return '<strong>' + d + '.' + m + '.' + r + '</strong> = Datum neexistuje!<br><small>PÅ™i pÅ™echodu z juliÃ¡nskÃ©ho na gregoriÃ¡nskÃ½ kalendÃ¡Å™ byly tyto dny pÅ™eskoÄeny</small>';
            }

            var cal, h;

            if (r < 1582 || (r === 1582 && m < 10) || (r === 1582 && m === 10 && d <= 4)) {
                cal = "ğŸ—“ juliÃ¡nskÃ½ ";
                var me, rr;
                if (m < 3) {
                    me = m + 12;
                    rr = r - 1;
                } else {
                    me = m;
                    rr = r;
                }
                h = ((d + Math.floor((13 * (me + 1)) / 5) + rr + Math.floor(rr / 4) - 1) % 7 + 7) % 7;
                var daysJulian = ["PÃ¡tek", "Sobota", "NedÄ›le", "PondÄ›lÃ­", "ÃšterÃ½", "StÅ™eda", "ÄŒtvrtek"];
                return 'ğŸ—“ï¸ <strong>' + d + '.' + m + '.' + r + '</strong> = <strong>' + daysJulian[h] + '</strong><br><small>' + cal + (isLeapYear(r) ? ' â€¢ pÅ™estupnÃ½' : '') + '</small>';
            } else {
                cal = "ğŸ—“ gregoriÃ¡nskÃ½ ";
                var me, rr;
                if (m < 3) {
                    me = m + 12;
                    rr = r - 1;
                } else {
                    me = m;
                    rr = r;
                }
                var k = rr % 100;
                var j = Math.floor(rr / 100);
                h = ((d + Math.floor((13 * (me + 1)) / 5) + k + Math.floor(k / 4) + Math.floor(j / 4) - (2 * j)) % 7 + 7) % 7;
                var daysGregorian = ["Sobota", "NedÄ›le", "PondÄ›lÃ­", "ÃšterÃ½", "StÅ™eda", "ÄŒtvrtek", "PÃ¡tek"];
                return 'ğŸ—“ï¸ <strong>' + d + '.' + m + '.' + r + '</strong> = <strong>' + daysGregorian[h] + '</strong><br><small>' + cal + (isLeapYear(r) ? ' â€¢ pÅ™estupnÃ½' : '') + '</small>';
            }
        } catch (e) {
            return "âŒ Chyba ve vÃ½poÄtu";
        }
    }
    
    function getDayOfWeekSimple(d, m, r) {
        var me = m, rr = r;
        if (m < 3) {
            me = m + 12;
            rr = r - 1;
        }
        
        if (r < 1582 || (r === 1582 && m < 10) || (r === 1582 && m === 10 && d <= 4)) {
            var h = ((d + Math.floor((13 * (me + 1)) / 5) + rr + Math.floor(rr / 4) - 1) % 7 + 7) % 7;
            var daysJulian = ["pÃ¡tek", "sobota", "nedÄ›le", "pondÄ›lÃ­", "ÃºterÃ½", "stÅ™eda", "Ätvrtek"];
            return daysJulian[h];
        } else {
            var k = rr % 100;
            var j = Math.floor(rr / 100);
            var h = ((d + Math.floor((13 * (me + 1)) / 5) + k + Math.floor(k / 4) + Math.floor(j / 4) - (2 * j)) % 7 + 7) % 7;
            var daysGregorian = ["sobota", "nedÄ›le", "pondÄ›lÃ­", "ÃºterÃ½", "stÅ™eda", "Ätvrtek", "pÃ¡tek"];
            return daysGregorian[h];
        }
    }
    
    // Julian day number calculations
    function getJulianDayNumber(day, month, year, isJulian) {
        if (isJulian === undefined) isJulian = false;
        
        var a = Math.floor((14 - month) / 12);
        var y = year + 4800 - a;
        var m = month + 12 * a - 3;
        
        var jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4);
        
        if (!isJulian) {
            jdn = jdn - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
        } else {
            jdn = jdn - 32083;
        }
        
        return jdn;
    }
    
    function getDateFromJulianDay(jdn, isJulian) {
        if (isJulian === undefined) isJulian = false;
        
        var a, b, c, d, e;
        
        if (!isJulian) {
            a = jdn + 32044;
            b = Math.floor((4 * a + 3) / 146097);
            c = a - Math.floor((146097 * b) / 4);
            d = Math.floor((4 * c + 3) / 1461);
            e = c - Math.floor((1461 * d) / 4);
        } else {
            a = jdn + 32082;
            d = Math.floor((4 * a + 3) / 1461);
            e = a - Math.floor((1461 * d) / 4);
        }
        
        var m = Math.floor((5 * e + 2) / 153);
        var day = e - Math.floor((153 * m + 2) / 5) + 1;
        var month = m + 3 - 12 * Math.floor(m / 10);
        var year = (!isJulian ? 100 * b : 0) + d - 4800 + Math.floor(m / 10);
        
        return { day: day, month: month, year: year };
    }
    
    // Date arithmetic
    function addDays(date, days) {
        var newDate = new Date(date.year, date.month - 1, date.day);
        newDate.setDate(newDate.getDate() + days);
        return {
            day: newDate.getDate(),
            month: newDate.getMonth() + 1,
            year: newDate.getFullYear()
        };
    }
    
    function formatDate(date) {
        return date.day + '.' + date.month + '.' + date.year;
    }
    
    // Easter calculation
    function getEasterDate(year) {
        var a = year % 19;
        var b = Math.floor(year / 100);
        var c = year % 100;
        var d = Math.floor(b / 4);
        var e = b % 4;
        var f = Math.floor((b + 8) / 25);
        var g = Math.floor((b - f + 1) / 3);
        var h = (19 * a + b - d - g + 15) % 30;
        var i = Math.floor(c / 4);
        var k = c % 4;
        var l = (32 + 2 * e + 2 * i - h - k) % 7;
        var m = Math.floor((a + 11 * h + 22 * l) / 451);
        var month = Math.floor((h + l - 7 * m + 114) / 31);
        var day = ((h + l - 7 * m + 114) % 31) + 1;
        
        return { day: day, month: month, year: year };
    }
    
    // Enhanced Moon phase calculations
    function getMoonAge(day, month, year) {
        var jd = getJulianDayNumber(day, month, year);
        var newMoonJD = 2451549.5; // JD novÃ©ho mÄ›sÃ­ce 6.1.2000
        var synodicMonth = 29.53058867; // synodickÃ½ mÄ›sÃ­c ve dnech
        
        var daysSinceNewMoon = (jd - newMoonJD) % synodicMonth;
        if (daysSinceNewMoon < 0) daysSinceNewMoon += synodicMonth;
        
        return daysSinceNewMoon;
    }
    
    function getMoonPhase(age) {
        if (age < 1.84566) return "Nov";
        else if (age < 5.53699) return "DorÅ¯stajÃ­cÃ­ srpek";
        else if (age < 9.22831) return "PrvnÃ­ ÄtvrÅ¥";
        else if (age < 12.91963) return "DorÅ¯stajÃ­cÃ­ mÄ›sÃ­c";
        else if (age < 16.61096) return "ÃšplnÄ›k";
        else if (age < 20.30228) return "UbÃ½vajÃ­cÃ­ mÄ›sÃ­c";
        else if (age < 23.99361) return "PoslednÃ­ ÄtvrÅ¥";
        else if (age < 27.68493) return "UbÃ½vajÃ­cÃ­ srpek";
        else return "Nov";
    }
    
    function getMoonEmoji(age) {
        if (age < 1.84566) return "ğŸŒ‘";
        else if (age < 5.53699) return "ğŸŒ’";
        else if (age < 9.22831) return "ğŸŒ“";
        else if (age < 12.91963) return "ğŸŒ”";
        else if (age < 16.61096) return "ğŸŒ•";
        else if (age < 20.30228) return "ğŸŒ–";
        else if (age < 23.99361) return "ğŸŒ—";
        else if (age < 27.68493) return "ğŸŒ˜";
        else return "ğŸŒ‘";
    }

    // Corrected sun events calculations using NOAA algorithm with proper timezone handling
    function calculateSunEvents(day, month, year, latitude, longitude) {
        try {
            var jd = getJulianDayNumber(day, month, year);
            var T = (jd - 2451545.0) / 36525.0; // Centuries since J2000
            
            // Check for polar regions
            if (Math.abs(latitude) > 66.5) {
                return handlePolarRegions(day, month, year, latitude, longitude);
            }
            
            // Solar mean longitude (degrees)
            var L0 = (280.46646 + T * (36000.76983 + T * 0.0003032)) % 360;
            if (L0 < 0) L0 += 360;
            
            // Solar mean anomaly (degrees)  
            var M = (357.52911 + T * (35999.05029 - T * 0.0001537)) % 360;
            var M_rad = M * Math.PI / 180;
            
            // Earth's eccentricity
            var e = 0.016708634 - T * (0.000042037 + T * 0.0000001267);
            
            // Sun's equation of center (degrees)
            var C = Math.sin(M_rad) * (1.914602 - T * (0.004817 + T * 0.000014)) +
                    Math.sin(2 * M_rad) * (0.019993 - T * 0.000101) +
                    Math.sin(3 * M_rad) * 0.000289;
            
            // True longitude (degrees)
            var trueLon = L0 + C;
            
            // Apparent longitude - nutation correction (degrees)
            var omega = (125.04 - 1934.136 * T) * Math.PI / 180;
            var apparentLon = trueLon - 0.00569 - 0.00478 * Math.sin(omega);
            
            // Obliquity of ecliptic (degrees)
            var epsilon0 = 23 + (26 + (21.448 - T * (46.815 + T * (0.00059 - T * 0.001813))) / 60) / 60;
            var epsilon = epsilon0 + 0.00256 * Math.cos(omega);
            var epsilon_rad = epsilon * Math.PI / 180;
            var apparentLon_rad = apparentLon * Math.PI / 180;
            
            // Solar declination (radians)
            var declination = Math.asin(Math.sin(epsilon_rad) * Math.sin(apparentLon_rad));
            
            // Equation of time (minutes)
            var y = Math.pow(Math.tan(epsilon_rad / 2), 2);
            var L0_rad = L0 * Math.PI / 180;
            var eqTime = 4 * (180 / Math.PI) * (
                y * Math.sin(2 * L0_rad) - 
                2 * e * Math.sin(M_rad) +
                4 * e * y * Math.sin(M_rad) * Math.cos(2 * L0_rad) -
                0.5 * y * y * Math.sin(4 * L0_rad) -
                1.25 * e * e * Math.sin(2 * M_rad)
            );
            
            // Hour angle for sunrise/sunset (including atmospheric refraction)
            var latRad = latitude * Math.PI / 180;
            var zenith = 90.833; // 90Â° + 50' atmospheric refraction + 16' solar radius
            var cosHA = (Math.cos(zenith * Math.PI / 180) - Math.sin(latRad) * Math.sin(declination)) / 
                       (Math.cos(latRad) * Math.cos(declination));
            
            // Check for polar day/night
            if (cosHA > 1) {
                return {
                    sunrise: "Slunce nevychÃ¡zÃ­",
                    sunset: "Slunce nevychÃ¡zÃ­", 
                    dayLength: "0:00",
                    declination: (declination * 180 / Math.PI).toFixed(2) + 'Â°',
                    polarNight: true
                };
            }
            if (cosHA < -1) {
                return {
                    sunrise: "Slunce nezapadÃ¡",
                    sunset: "Slunce nezapadÃ¡",
                    dayLength: "24:00", 
                    declination: (declination * 180 / Math.PI).toFixed(2) + 'Â°',
                    polarDay: true
                };
            }
            
            var HA = Math.acos(cosHA) * 180 / Math.PI; // Hour angle in degrees
            
            // Get timezone for the location
            var timezone = determineTimezone(longitude, month);
            
            // Calculate times in solar time first
            var solarNoon = 12 - eqTime / 60; // Solar noon in solar time
            var sunriseUTC = solarNoon - HA / 15 - longitude / 15; // UTC time
            var sunsetUTC = solarNoon + HA / 15 - longitude / 15; // UTC time
            
            // Convert UTC to local time
            var sunrise = sunriseUTC + timezone;
            var sunset = sunsetUTC + timezone;
            
            // Ensure times are in 0-24 range
            while (sunrise < 0) sunrise += 24;
            while (sunrise >= 24) sunrise -= 24;
            while (sunset < 0) sunset += 24;
            while (sunset >= 24) sunset -= 24;
            
            // Calculate day length
            var dayLengthHours = HA * 2 / 15; // Hours of daylight
            var dayLengthHour = Math.floor(dayLengthHours);
            var dayLengthMin = Math.round((dayLengthHours - dayLengthHour) * 60);
            
            return {
                sunrise: formatTime(sunrise),
                sunset: formatTime(sunset),
                dayLength: formatHoursMinutes(dayLengthHour, dayLengthMin),
                declination: (declination * 180 / Math.PI).toFixed(2) + 'Â°',
                eqTime: eqTime.toFixed(1) + ' min',
                timezone: 'UTC' + (timezone >= 0 ? '+' : '') + timezone
            };
            
        } catch (error) {
            return {
                sunrise: "Chyba vÃ½poÄtu",
                sunset: "Chyba vÃ½poÄtu", 
                dayLength: "---",
                declination: "---"
            };
        }
    }

    function determineTimezone(longitude, month) {
        // Basic timezone from longitude (15Â° = 1 hour)
        var basicTZ = Math.round(longitude / 15);
        
        // DST logic for European rules
        var isDST = false;
        
        // European DST: last Sunday in March to last Sunday in October
        if (month > 3 && month < 10) {
            // Definitely DST (April to September)
            isDST = true;
        } else if (month === 3) {
            // March - DST starts around March 25-31 (simplified)
            isDST = true; // Could be refined to check actual date
        } else if (month === 10) {
            // October - DST ends around October 25-31 (simplified)
            isDST = false; // Could be refined to check actual date
        }
        // For months 1,2,11,12 (Jan,Feb,Nov,Dec) isDST remains false
        
        // Timezone corrections for specific regions
        if (longitude >= -10 && longitude <= 40) { // Europe roughly
            if (longitude >= -10 && longitude <= 5) { // Western Europe (UK, Portugal, western France)
                return isDST ? 1 : 0; // GMT/BST
            } else if (longitude >= 5 && longitude <= 15) { // Central Europe (CET/CEST)
                return isDST ? 2 : 1; // CET/CEST
            } else if (longitude >= 15 && longitude <= 30) { // Eastern Europe (EET/EEST)
                return isDST ? 3 : 2; // EET/EEST
            } else { // Further east
                return isDST ? 4 : 3;
            }
        }
        
        // For other regions outside Europe, use basic calculation
        return basicTZ + (isDST ? 1 : 0);
    }

    function handlePolarRegions(day, month, year, latitude, longitude) {
        // Simplified polar region handling
        var jd = getJulianDayNumber(day, month, year);
        var T = (jd - 2451545.0) / 36525.0;
        var L0 = (280.46646 + T * (36000.76983 + T * 0.0003032)) % 360;
        var M = (357.52911 + T * (35999.05029 - T * 0.0001537)) % 360;
        var C = Math.sin(M * Math.PI / 180) * 1.914602;
        var trueLon = L0 + C;
        var epsilon = 23.4393 - 0.0130 * T;
        var declination = Math.asin(Math.sin(epsilon * Math.PI / 180) * Math.sin(trueLon * Math.PI / 180));
        
        // Determine if it's polar day or night
        var isPolarDay = (latitude > 0 && declination > (90 - latitude) * Math.PI / 180) ||
                         (latitude < 0 && declination < (90 + latitude) * Math.PI / 180);
        var isPolarNight = (latitude > 0 && declination < -(90 - latitude) * Math.PI / 180) ||
                           (latitude < 0 && declination > -(90 + latitude) * Math.PI / 180);
        
        if (isPolarDay) {
            return {
                sunrise: "Slunce nezapadÃ¡",
                sunset: "Slunce nezapadÃ¡", 
                dayLength: "24:00",
                declination: (declination * 180 / Math.PI).toFixed(2) + 'Â°',
                polarDay: true
            };
        } else if (isPolarNight) {
            return {
                sunrise: "Slunce nevychÃ¡zÃ­",
                sunset: "Slunce nevychÃ¡zÃ­",
                dayLength: "0:00", 
                declination: (declination * 180 / Math.PI).toFixed(2) + 'Â°',
                polarNight: true
            };
        } else {
            // Use standard calculation for border cases
            return calculateSunEvents(day, month, year, latitude, longitude);
        }
    }

    function formatTime(hours) {
        var h = Math.floor(hours);
        var mFloat = (hours - h) * 60;
        var m = Math.floor(mFloat);
        var s = Math.round((mFloat - m) * 60);

        // Korekce pÅ™eteÄenÃ­ sekund
        if (s === 60) {
            s = 0;
            m++;
        }
        if (m === 60) {
            m = 0;
            h++;
        }
        if (h >= 24) h -= 24;
        if (h < 0) h += 24;

        return (h < 10 ? '0' : '') + h + ':' +
               (m < 10 ? '0' : '') + m + ':' +
               (s < 10 ? '0' : '') + s;
    }

    function formatHoursMinutes(hours, minutes) {
        if (minutes >= 60) { hours++; minutes -= 60; }
        return (hours < 10 ? '0' : '') + hours + ':' + (minutes < 10 ? '0' : '') + minutes;
    }
        
    // Geocentric planet positions as seen from Earth
    function getPlanetPositions(day, month, year, hour, minute, timezone) {
        // Default values if time not provided
        if (hour === undefined) hour = 0;
        if (minute === undefined) minute = 0;
        if (timezone === undefined) timezone = 0;
        
        // Convert to Julian Day with time
        var jd = getJulianDayNumber(day, month, year);
        
        // Add time component (convert local time to UTC)
        var timeOffset = (hour - timezone + minute / 60.0) / 24.0;
        jd += timeOffset;
        
        var T = (jd - 2451545.0) / 36525; // Centuries since J2000
        
        // Calculate Earth's position first
        var earthLongitude = getEarthPosition(T);
        
        var planets = [];
        
        // Inner planets (Mercury, Venus)
        var mercury = calculateInnerPlanet("Merkur", T, 252.25, 149472.67, 0.387, 0.206, earthLongitude);
        planets.push(mercury);
        
        var venus = calculateInnerPlanet("VenuÅ¡e", T, 181.98, 58517.82, 0.723, 0.007, earthLongitude);
        planets.push(venus);
        
        // Outer planets (Mars, Jupiter, Saturn)
        var mars = calculateOuterPlanet("Mars", T, 355.43, 19140.30, 1.524, 0.093, earthLongitude);
        planets.push(mars);
        
        var jupiter = calculateOuterPlanet("Jupiter", T, 34.35, 3034.74, 5.203, 0.048, earthLongitude);
        planets.push(jupiter);
        
        var saturn = calculateOuterPlanet("Saturn", T, 50.08, 1222.11, 9.537, 0.054, earthLongitude);
        planets.push(saturn);
        
        return planets;
    }

    function getEarthPosition(T) {
        // Earth's mean longitude
        var L = (100.464 + 35999.372 * T) % 360;
        if (L < 0) L += 360;
        
        // Earth's mean anomaly
        var M = (357.528 + 35999.050 * T) % 360;
        var M_rad = M * Math.PI / 180;
        
        // Equation of center
        var C = 1.915 * Math.sin(M_rad) + 0.020 * Math.sin(2 * M_rad);
        
        // True longitude
        var trueLongitude = (L + C) % 360;
        if (trueLongitude < 0) trueLongitude += 360;
        
        return trueLongitude;
    }

    function calculateInnerPlanet(name, T, L0, n, a, e, earthLong) {
        // More accurate planetary calculations
        var planetConstants = getPlanetConstants(name);
        
        // Mean longitude with higher precision
        var L = (planetConstants.L0 + planetConstants.n * T + planetConstants.n2 * T * T) % 360;
        if (L < 0) L += 360;
        
        // Mean anomaly
        var M = (planetConstants.M0 + planetConstants.M1 * T) % 360;
        var M_rad = M * Math.PI / 180;
        
        // Equation of center (simplified)
        var C = planetConstants.e * Math.sin(M_rad) * (180 / Math.PI);
        
        // True longitude
        var trueLong = (L + C) % 360;
        if (trueLong < 0) trueLong += 360;
        
        // Calculate elongation from Sun (as seen from Earth)
        var elongation = Math.abs(trueLong - earthLong);
        if (elongation > 180) elongation = 360 - elongation;
        
        // More accurate geocentric position
        var geocentricLong = calculateGeocentricPosition(trueLong, earthLong, a, true);
        
        var visibility = getAdvancedVisibility(name, elongation, trueLong, earthLong);
        var constellation = getConstellation(geocentricLong);
        var magnitude = calculateMagnitude(name, elongation, a);
        
        return {
            name: name,
            position: geocentricLong.toFixed(1) + "Â° (geocentrickÃ¡ dÃ©lka)",
            elongation: elongation.toFixed(1) + "Â° od Slunce",
            visibility: visibility,
            constellation: constellation,
            magnitude: magnitude,
            type: "VnitÅ™nÃ­ planeta"
        };
    }

    function getPlanetConstants(name) {
        var constants = {
            "Merkur": {
                L0: 252.25084, n: 149472.67486, n2: -0.00000536,
                M0: 174.79252, M1: 149472.51529, e: 0.20563175
            },
            "VenuÅ¡e": {
                L0: 181.97973, n: 58517.81539, n2: 0.00000165,
                M0: 50.44675, M1: 58517.81538, e: 0.00677192
            }
        };
        return constants[name] || constants["Merkur"];
    }

    function getOuterPlanetConstants(name) {
        var constants = {
            "Mars": {
                L0: 355.43299, n: 19140.29934, n2: 0.00000261,
                M0: 319.51913, M1: 19139.85475, e: 0.09341233
            },
            "Jupiter": {
                L0: 34.35148, n: 3034.74612, n2: -0.00008501,
                M0: 225.32833, M1: 3034.69202, e: 0.04849485
            },
            "Saturn": {
                L0: 50.07571, n: 1222.11494, n2: 0.00025899,
                M0: 175.46622, M1: 1221.55147, e: 0.05554814
            }
        };
        return constants[name] || constants["Mars"];
    }

    function calculateGeocentricPosition(planetLong, earthLong, planetDist, isInner) {
        // Simplified geometric calculation
        if (isInner) {
            // For inner planets, account for viewing angle from Earth
            var phase = (planetLong - earthLong + 360) % 360;
            return phase;
        } else {
            // For outer planets, direct geocentric longitude
            return planetLong;
        }
    }

    function getAdvancedVisibility(name, elongation, planetLong, earthLong) {
        if (name === "Merkur" || name === "VenuÅ¡e") {
            if (elongation < 10) return "NeviditelnÃ¡ (pÅ™Ã­liÅ¡ blÃ­zko Slunce)";
            if (elongation > 15 && elongation < 30) {
                var phase = (planetLong - earthLong + 360) % 360;
                if (phase > 180) return "RannÃ­ viditelnost (vÃ½chodnÃ­ elongace)";
                else return "VeÄernÃ­ viditelnost (zÃ¡padnÃ­ elongace)";
            }
            if (elongation >= 30) return "MaximÃ¡lnÃ­ viditelnost";
            return "Å patnÄ› viditelnÃ¡";
        } else {
            // Outer planets
            if (elongation < 30) return "V opozici (ideÃ¡lnÃ­ pozorovacÃ­ podmÃ­nky)";
            if (elongation < 90) return "DobÅ™e viditelnÃ¡ celou noc";
            if (elongation < 150) return "ViditelnÃ¡ veÄer/rÃ¡no";
            return "BlÃ­zko Slunce (neviditelnÃ¡)";
        }
    }

    function calculateMagnitude(name, elongation, distance) {
        // More accurate magnitude calculation
        var baseMag = {
            "Merkur": -0.4, 
            "VenuÅ¡e": -4.0, 
            "Mars": -2.0, 
            "Jupiter": -2.5, 
            "Saturn": 0.0
        };
        
        var mag = baseMag[name];
        if (mag === undefined) mag = 5.0; // fallback for unknown planets
        
        // Adjust for distance and phase (simplified)
        if (distance && !isNaN(distance)) {
            mag += Math.log10(distance) * 2.5; // distance modulus approximation
        }
        
        // Phase effect (opposition effect for outer planets)
        if (elongation < 30) {
            mag -= 0.3; // Opposition surge
        } else if (elongation > 150) {
            mag += 0.5; // Worse visibility when close to Sun
        }
        
        return mag.toFixed(1) + " mag";
    }

    function calculateOuterPlanet(name, T, L0, n, a, e, earthLong) {
        // More accurate planetary calculations
        var planetConstants = getOuterPlanetConstants(name);
        
        // Mean longitude with higher precision
        var L = (planetConstants.L0 + planetConstants.n * T + planetConstants.n2 * T * T) % 360;
        if (L < 0) L += 360;
        
        // Mean anomaly
        var M = (planetConstants.M0 + planetConstants.M1 * T) % 360;
        var M_rad = M * Math.PI / 180;
        
        // Equation of center (simplified)
        var C = planetConstants.e * Math.sin(M_rad) * (180 / Math.PI);
        
        // True longitude
        var trueLong = (L + C) % 360;
        if (trueLong < 0) trueLong += 360;
        
        // Calculate elongation from Sun (as seen from Earth)
        var elongation = Math.abs(trueLong - earthLong);
        if (elongation > 180) elongation = 360 - elongation;
        
        // Geocentric position (for outer planets, approximately same as heliocentric)
        var geocentricLong = trueLong;
        
        var visibility = getAdvancedVisibility(name, elongation, trueLong, earthLong);
        var constellation = getConstellation(geocentricLong);
        var magnitude = calculateMagnitude(name, elongation, a);
        
        return {
            name: name,
            position: geocentricLong.toFixed(1) + "Â° (geocentrickÃ¡ dÃ©lka)",
            elongation: elongation.toFixed(1) + "Â° od Slunce",
            visibility: visibility,
            constellation: constellation,
            magnitude: magnitude,
            type: "VnÄ›jÅ¡Ã­ planeta"
        };
    }

    function getConstellation(longitude) {
        // Simplified constellation mapping based on ecliptic longitude
        var constellations = [
            {start: 0, end: 30, name: "Beran"},
            {start: 30, end: 60, name: "BÃ½k"}, 
            {start: 60, end: 90, name: "BlÃ­Å¾enci"},
            {start: 90, end: 120, name: "Rak"},
            {start: 120, end: 150, name: "Lev"},
            {start: 150, end: 180, name: "Panna"},
            {start: 180, end: 210, name: "VÃ¡hy"},
            {start: 210, end: 240, name: "Å tÃ­r"},
            {start: 240, end: 270, name: "StÅ™elec"},
            {start: 270, end: 300, name: "Kozoroh"},
            {start: 300, end: 330, name: "VodnÃ¡Å™"},
            {start: 330, end: 360, name: "Ryby"}
        ];
        
        for (var i = 0; i < constellations.length; i++) {
            if (longitude >= constellations[i].start && longitude < constellations[i].end) {
                return constellations[i].name;
            }
        }
        return "Ryby"; // fallback
    }
        
    // Corrected eclipse calculations using real astronomical data
    function getEclipses(year) {
        var eclipses = [];
        
        // Database of real eclipse data for accurate years (2020-2030)
        var knownEclipses = {
            2020: [
                {type: "MÄ›sÃ­ÄnÃ­", date: "10.1.2020", visibility: "ViditelnÃ© z Evropy, Afriky, Asie"},
                {type: "SluneÄnÃ­", date: "21.6.2020", visibility: "PrstencovÃ© - Afrika, Asie"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "5.7.2020", visibility: "PenumbrÃ¡lnÃ­ - Amerika, jihozÃ¡padnÃ­ Evropa"},
                {type: "SluneÄnÃ­", date: "14.12.2020", visibility: "ÃšplnÃ© - Chile, Argentina"}
            ],
            2021: [
                {type: "SluneÄnÃ­", date: "10.6.2021", visibility: "PrstencovÃ© - severnÃ­ oblasti"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "26.5.2021", visibility: "ÃšplnÃ© - Pacifik, Amerika, Asie"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "19.11.2021", visibility: "ÄŒÃ¡steÄnÃ© - Amerika, severovÃ½chodnÃ­ Asie"},
                {type: "SluneÄnÃ­", date: "4.12.2021", visibility: "ÃšplnÃ© - Antarktida"}
            ],
            2022: [
                {type: "SluneÄnÃ­", date: "30.4.2022", visibility: "ÄŒÃ¡steÄnÃ© - jihovÃ½chodnÃ­ Pacifik"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "16.5.2022", visibility: "ÃšplnÃ© - Amerika, Evropa, Afrika"},
                {type: "SluneÄnÃ­", date: "25.10.2022", visibility: "ÄŒÃ¡steÄnÃ© - Evropa, severovÃ½chodnÃ­ Afrika, Asie"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "8.11.2022", visibility: "ÃšplnÃ© - Asie, AustrÃ¡lie, Pacifik, Amerika"}
            ],
            2023: [
                {type: "SluneÄnÃ­", date: "20.4.2023", visibility: "HybridnÃ­ - jihovÃ½chodnÃ­ Asie, AustrÃ¡lie"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "5.5.2023", visibility: "PenumbrÃ¡lnÃ­ - Afrika, Asie, AustrÃ¡lie"},
                {type: "SluneÄnÃ­", date: "14.10.2023", visibility: "PrstencovÃ© - Amerika"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "28.10.2023", visibility: "ÄŒÃ¡steÄnÃ© - Evropa, Asie, AustrÃ¡lie, Afrika"}
            ],
            2024: [
                {type: "MÄ›sÃ­ÄnÃ­", date: "25.3.2024", visibility: "PenumbrÃ¡lnÃ­ - Amerika"},
                {type: "SluneÄnÃ­", date: "8.4.2024", visibility: "ÃšplnÃ© - SevernÃ­ Amerika"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "18.9.2024", visibility: "ÄŒÃ¡steÄnÃ© - Amerika, Evropa, Afrika"},
                {type: "SluneÄnÃ­", date: "2.10.2024", visibility: "PrstencovÃ© - Pacifik, jiÅ¾nÃ­ Amerika"}
            ],
            2025: [
                {type: "MÄ›sÃ­ÄnÃ­", date: "14.3.2025", visibility: "ÃšplnÃ© - Amerika, zÃ¡padnÃ­ Evropa"},
                {type: "SluneÄnÃ­", date: "29.3.2025", visibility: "ÄŒÃ¡steÄnÃ© - Evropa, severozÃ¡padnÃ­ Afrika, Arktida"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "7.9.2025", visibility: "ÃšplnÃ© - Evropa, Afrika, Asie, AustrÃ¡lie"},
                {type: "SluneÄnÃ­", date: "21.9.2025", visibility: "ÄŒÃ¡steÄnÃ© - Pacifik, Antarktida"}
            ],
            2026: [
                {type: "SluneÄnÃ­", date: "17.2.2026", visibility: "PrstencovÃ© - Antarktida, jiÅ¾nÃ­ oblasti"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "3.3.2026", visibility: "ÃšplnÃ© - vÃ½chodnÃ­ Asie, AustrÃ¡lie, Pacifik, Amerika"},
                {type: "SluneÄnÃ­", date: "12.8.2026", visibility: "ÃšplnÃ© - GrÃ³nsko, Island, Å panÄ›lsko, Rusko"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "28.8.2026", visibility: "ÄŒÃ¡steÄnÃ© - vÃ½chodnÃ­ Pacifik, Amerika, zÃ¡padnÃ­ Afrika"}
            ],
            2027: [
                {type: "SluneÄnÃ­", date: "6.2.2027", visibility: "PrstencovÃ© - jiÅ¾nÃ­ Pacifik, Chile, Argentina"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "21.2.2027", visibility: "PenumbrÃ¡lnÃ­ - Amerika, Evropa, Afrika, Asie"},
                {type: "SluneÄnÃ­", date: "2.8.2027", visibility: "ÃšplnÃ© - Atlantik, Å panÄ›lsko, Afrika, Asie"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "17.8.2027", visibility: "PenumbrÃ¡lnÃ­ - Asie, AustrÃ¡lie, Pacifik"}
            ],
            2028: [
                {type: "SluneÄnÃ­", date: "26.1.2028", visibility: "PrstencovÃ© - EkvÃ¡dor, BrazÃ­lie, Å panÄ›lsko, Portugalsko"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "12.7.2028", visibility: "ÄŒÃ¡steÄnÃ© - Evropa, Afrika, zÃ¡padnÃ­ Asie"},
                {type: "SluneÄnÃ­", date: "22.7.2028", visibility: "ÃšplnÃ© - IndickÃ½ oceÃ¡n, AustrÃ¡lie, NovÃ½ ZÃ©land"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "6.1.2029", visibility: "ÃšplnÃ© - vÃ½chodnÃ­ Pacifik, Amerika, zÃ¡padnÃ­ Evropa"}
            ],
            2029: [
                {type: "MÄ›sÃ­ÄnÃ­", date: "6.1.2029", visibility: "ÃšplnÃ© - Amerika, Evropa"},
                {type: "SluneÄnÃ­", date: "14.6.2029", visibility: "ÄŒÃ¡steÄnÃ© - Arktida"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "31.12.2029", visibility: "ÃšplnÃ© - Evropa, Afrika, Asie, AustrÃ¡lie"}
            ],
            2030: [
                {type: "SluneÄnÃ­", date: "1.6.2030", visibility: "PrstencovÃ© - AlÅ¾Ã­rsko, Tunisko, Å˜ecko, Turecko, Rusko"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "15.6.2030", visibility: "ÄŒÃ¡steÄnÃ© - Evropa, Afrika, Asie, AustrÃ¡lie"},
                {type: "SluneÄnÃ­", date: "25.11.2030", visibility: "ÄŒÃ¡steÄnÃ© - jiÅ¾nÃ­ Afrika, Antarktida"},
                {type: "MÄ›sÃ­ÄnÃ­", date: "9.12.2030", visibility: "PenumbrÃ¡lnÃ­ - Evropa, Asie, AustrÃ¡lie, Pacifik"}
            ]
        };
        
        // If we have exact data, use it
        if (knownEclipses[year]) {
            return knownEclipses[year];
        }
        
        // For other years, use simplified Saros cycle approximation
        return calculateEclipsesUsingSaros(year);
    }

    function calculateEclipsesUsingSaros(year) {
        var eclipses = [];
        
        // Reference eclipses from known Saros series
        var sarosReferences = [
            // Saros 136 - major solar eclipse series
            {type: "SluneÄnÃ­", referenceYear: 2017, referenceMonth: 8, referenceDay: 21, 
             sarosNumber: 136, nextYears: [2035, 2053, 2071]},
            
            // Saros 142 - active solar series  
            {type: "SluneÄnÃ­", referenceYear: 2023, referenceMonth: 4, referenceDay: 20,
             sarosNumber: 142, nextYears: [2041, 2059, 2077]},
             
            // Saros 131 - lunar eclipse series
            {type: "MÄ›sÃ­ÄnÃ­", referenceYear: 2018, referenceMonth: 1, referenceDay: 31,
             sarosNumber: 131, nextYears: [2036, 2054, 2072]},
             
            // Saros 134 - lunar eclipse series  
            {type: "MÄ›sÃ­ÄnÃ­", referenceYear: 2021, referenceMonth: 5, referenceDay: 26,
             sarosNumber: 134, nextYears: [2039, 2057, 2075]}
        ];
        
        var sarosPeriod = 18.031; // Saros cycle in years (more precise than 18)
        var currentYear = new Date().getFullYear();
        
        for (var i = 0; i < sarosReferences.length; i++) {
            var ref = sarosReferences[i];
            var yearsSinceReference = year - ref.referenceYear;
            
            // Check if this year should have an eclipse from this Saros series
            var cyclesFromReference = yearsSinceReference / sarosPeriod;
            var isCloseToSarosCycle = Math.abs(cyclesFromReference - Math.round(cyclesFromReference)) < 0.1;
            
            if (isCloseToSarosCycle && Math.abs(yearsSinceReference) <= 200) {
                // Calculate approximate date using Saros shift
                var monthShift = Math.round(cyclesFromReference * 0.37); // Small monthly shift over time
                var dayShift = Math.round(cyclesFromReference * 11 * 0.33); // ~11 days per Saros
                
                var newMonth = ref.referenceMonth + monthShift;
                var newDay = ref.referenceDay + dayShift;
                
                // Normalize month and day
                while (newMonth > 12) {
                    newMonth -= 12;
                }
                while (newMonth < 1) {
                    newMonth += 12;
                }
                while (newDay > 31) {
                    newDay -= 30;
                }
                while (newDay < 1) {
                    newDay += 30;
                }
                
                // Determine visibility based on geographical shift
                var longitude = (cyclesFromReference * 120) % 360; // 120Â° shift per Saros
                var visibility = getVisibilityFromLongitude(longitude, ref.type);
                
                eclipses.push({
                    type: ref.type,
                    date: newDay + "." + newMonth + "." + year,
                    visibility: visibility,
                    sarosInfo: "Saros " + ref.sarosNumber + " (cyklus " + Math.round(cyclesFromReference) + ")"
                });
            }
        }
        
        // If no eclipses found through Saros, add statistical approximation
        if (eclipses.length === 0) {
            eclipses = getStatisticalEclipses(year);
        }
        
        // Sort by date
        eclipses.sort(function(a, b) {
            var dateA = new Date(a.date.split('.').reverse().join('-'));
            var dateB = new Date(b.date.split('.').reverse().join('-'));
            return dateA - dateB;
        });
        
        return eclipses;
    }

    function getVisibilityFromLongitude(longitude, type) {
        var visibilityRegions = {
            solar: [
                "SevernÃ­ Amerika", "JiÅ¾nÃ­ Amerika", "Evropa", "Afrika", 
                "Asie", "AustrÃ¡lie", "Pacifik", "Atlantik", "Arktida", "Antarktida"
            ],
            lunar: [
                "CelÃ¡ noÄnÃ­ hemisfÃ©ra", "Amerika a zÃ¡padnÃ­ Evropa", "Evropa, Afrika, Asie",
                "Asie, AustrÃ¡lie, Pacifik", "Amerika", "Evropa a Afrika"
            ]
        };
        
        var regions = type === "SluneÄnÃ­" ? visibilityRegions.solar : visibilityRegions.lunar;
        var index = Math.floor(longitude / 60) % regions.length;
        
        return regions[index];
    }

    function getStatisticalEclipses(year) {
        // Fallback statistical method for distant years
        var eclipses = [];
        
        // On average, there are 2-3 solar and 2-3 lunar eclipses per year
        var numSolar = 2;
        var numLunar = 2;
        
        // Generate eclipses based on eclipse seasons (roughly every 6 months)
        var eclipseSeasons = [
            {month: 2 + (year % 3), type: "SluneÄnÃ­"},
            {month: 5 + (year % 2), type: "MÄ›sÃ­ÄnÃ­"},
            {month: 8 + (year % 3), type: "SluneÄnÃ­"},
            {month: 11 + (year % 2), type: "MÄ›sÃ­ÄnÃ­"}
        ];
        
        for (var i = 0; i < eclipseSeasons.length && i < 4; i++) {
            var season = eclipseSeasons[i];
            var day = 15 + ((year * 7 + i * 3) % 15) - 7; // Varies between 8-22
            
            if (day < 1) day = 1;
            if (day > 28) day = 28;
            
            eclipses.push({
                type: season.type,
                date: day + "." + season.month + "." + year,
                visibility: "VypoÄÃ­tÃ¡no statisticky - zkontrolujte dalÅ¡Ã­ zdroje",
                note: "Aproximace pro vzdÃ¡lenÃ½ rok"
            });
        }
        
        return eclipses;
    }
        
    // Corrected Sidereal time calculation with improved timezone handling
    function getSiderealTime(day, month, year, hour, minute, longitude, dstOffset) {
        if (dstOffset === undefined) dstOffset = 0;
        
        // Calculate standard timezone from longitude (15Â° = 1 hour)
        var baseTimezone = Math.round(longitude / 15);
        
        // Apply DST offset
        var totalTimezone = baseTimezone + dstOffset;
        
        // Convert local time to UTC
        var utcHour = hour - totalTimezone;
        var utcMinute = minute;
        
        // Handle day overflow/underflow when converting to UTC
        var utcDay = day;
        var utcMonth = month;
        var utcYear = year;
        
        if (utcHour < 0) {
            utcHour += 24;
            utcDay--;
            if (utcDay < 1) {
                utcMonth--;
                if (utcMonth < 1) {
                    utcMonth = 12;
                    utcYear--;
                }
                var daysInPrevMonth = [31, isLeapYear(utcYear) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                utcDay = daysInPrevMonth[utcMonth - 1];
            }
        } else if (utcHour >= 24) {
            utcHour -= 24;
            utcDay++;
            var daysInMonth = [31, isLeapYear(utcYear) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            if (utcDay > daysInMonth[utcMonth - 1]) {
                utcDay = 1;
                utcMonth++;
                if (utcMonth > 12) {
                    utcMonth = 1;
                    utcYear++;
                }
            }
        }
        
        // USNO Algorithm for Greenwich Mean Sidereal Time
        var jd0 = Math.floor(getJulianDayNumber(utcDay, utcMonth, utcYear)) + 0.5; // Midnight JD
        var H = utcHour + utcMinute / 60.0; // Hours since midnight UTC
        var DUT = jd0 - 2451545.0; // Days since J2000.0 epoch
        var T = DUT / 36525; // Centuries since J2000.0
        
        // Greenwich Mean Sidereal Time (USNO formula)
        var GMST = 6.697375 + 0.065709824279 * DUT + 1.0027379 * H + 0.0000258 * T * T;
        GMST = GMST % 24;
        if (GMST < 0) GMST += 24;
        
        // Local Sidereal Time (add longitude in hours)
        var LST = GMST + longitude / 15;
        LST = LST % 24;
        if (LST < 0) LST += 24;
        
        // Convert GMST to h:m:s format
        var gstH = Math.floor(GMST);
        var gstM = Math.floor((GMST - gstH) * 60);
        var gstS = Math.round(((GMST - gstH) * 60 - gstM) * 60);
        
        if (gstS >= 60) { gstM++; gstS = 0; }
        if (gstM >= 60) { gstH++; gstM = 0; }
        
        // Convert LST to h:m:s format
        var lstH = Math.floor(LST);
        var lstM = Math.floor((LST - lstH) * 60);
        var lstS = Math.round(((LST - lstH) * 60 - lstM) * 60);
        
        if (lstS >= 60) { lstM++; lstS = 0; }
        if (lstM >= 60) { lstH++; lstM = 0; }
        
        // Create timezone description
        var timezoneDesc = "UTC" + (totalTimezone >= 0 ? "+" : "") + totalTimezone;
        if (dstOffset > 0) {
            timezoneDesc += " (s letnÃ­m Äasem)";
        }
        
        return {
            gst: gstH + ":" + (gstM < 10 ? '0' : '') + gstM + ":" + (gstS < 10 ? '0' : '') + gstS,
            lst: lstH + ":" + (lstM < 10 ? '0' : '') + lstM + ":" + (lstS < 10 ? '0' : '') + lstS,
            lstDegrees: (LST * 15).toFixed(2) + "Â°",
            timezone: timezoneDesc,
            utcTime: (utcHour < 10 ? '0' : '') + utcHour + ":" + (utcMinute < 10 ? '0' : '') + utcMinute
        };
    }
    
    // Math type operation toggle
    function toggleMathOperation() {
        var mathType = document.getElementById('mathType').value;
        var addOp = document.getElementById('addOperation');
        var diffOp = document.getElementById('diffOperation');
        
        if (mathType === 'add') {
            addOp.style.display = 'block';
            diffOp.style.display = 'none';
        } else {
            addOp.style.display = 'none';
            diffOp.style.display = 'block';
        }
        clearDisplay();
    }

    // Main calculator functions - VÅ ECHNY ZACHOVANÃ‰ PÅ˜ESNÄš
    function calculateDayOfWeek() {
        try {
            var dateInput = document.getElementById('dateInput');
            if (!dateInput) return;

            var dateString = dateInput.value.trim();
            if (!dateString) {
                showError("Zadejte datum v libovolnÃ©m formÃ¡tu");
                return;
            }

            var parsed = parseDate(dateString);
            if (!parsed) {
                showError("NeplatnÃ½ formÃ¡t data. Zkuste: 1.1.1, 15.3.44, 1/3/89, 01031989");
                return;
            }

            var error = validateDate(parsed.day, parsed.month, parsed.year);
            if (error) {
                showError(error);
                return;
            }

            showLoading();
            setTimeout(function() {
                var result = getDayOfWeek(parsed.day, parsed.month, parsed.year);
                showResult(result);
            }, 300);
        } catch (e) {
            showError("DoÅ¡lo k chybÄ› pÅ™i vÃ½poÄtu");
        }
    }
    
    function calculateYearFinder() {
        var day = parseInt(document.getElementById('yearFinderDay').value);
        var month = parseInt(document.getElementById('yearFinderMonth').value);
        var dayOfWeek = parseInt(document.getElementById('yearFinderDayOfWeek').value);
        
        if (!day || !month || isNaN(dayOfWeek)) {
            showError("VyplÅˆte vÅ¡echna pole");
            return;
        }
        
        if (day < 1 || day > 31 || month < 1 || month > 12) {
            showError("NeplatnÃ½ den nebo mÄ›sÃ­c");
            return;
        }
        
        showLoading();
        setTimeout(function() {
            var years = [];
            var dayNames = ["nedÄ›le", "pondÄ›lÃ­", "ÃºterÃ½", "stÅ™eda", "Ätvrtek", "pÃ¡tek", "sobota"];
            
            for (var year = 2000; year <= 2100; year++) {
                var daysInMonth = [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                if (day <= daysInMonth[month - 1]) {
                    var me = month, rr = year;
                    if (month < 3) {
                        me = month + 12;
                        rr = year - 1;
                    }
                    var k = rr % 100;
                    var j = Math.floor(rr / 100);
                    var h = ((day + Math.floor((13 * (me + 1)) / 5) + k + Math.floor(k / 4) + Math.floor(j / 4) - (2 * j)) % 7 + 7) % 7;
                    var calculatedDayOfWeek = (h + 6) % 7;
                    
                    if (calculatedDayOfWeek === dayOfWeek) {
                        years.push(year + (isLeapYear(year) ? ' <strong>(pÅ™estupnÃ½)</strong>' : ''));
                    }
                }
            }
            
            if (years.length > 0) {
                showResult('<strong>' + day + '.' + month + '. pÅ™ipadÃ¡ na ' + dayNames[dayOfWeek] + ' v letech:</strong><br><small>' + years.join(', ') + '</small>');
            } else {
                showResult('Pro zadanÃ© parametry nebyli nalezeni Å¾Ã¡dnÃ© roky v obdobÃ­ 2000-2100');
            }
        }, 300);
    }
    
    function calculateConverter() {
        var dateStr = document.getElementById('converterDate').value.trim();
        var type = document.getElementById('converterType').value;
        
        if (!dateStr) {
            showError("Zadejte datum");
            return;
        }
        
        var parsed = parseDate(dateStr);
        if (!parsed) {
            showError("NeplatnÃ½ formÃ¡t data");
            return;
        }
        
        showLoading();
        setTimeout(function() {
            var result = '';
            if (type === 'gregorian') {
                var julianDay = getJulianDayNumber(parsed.day, parsed.month, parsed.year);
                var julianDate = getDateFromJulianDay(julianDay, true);
                var julianJDN = getJulianDayNumber(parsed.day, parsed.month, parsed.year, true);
                var rozdil = julianDay - julianJDN;

                result = '<strong>GregoriÃ¡nskÃ½:</strong> ' + parsed.day + '.' + parsed.month + '.' + parsed.year + 
                        '<br><strong>JuliÃ¡nskÃ½:</strong> ' + julianDate.day + '.' + julianDate.month + '.' + julianDate.year +
                        '<br><small>RozdÃ­l: ' + rozdil + ' dnÃ­</small>';
            } else {
                var julianDay = getJulianDayNumber(parsed.day, parsed.month, parsed.year, true);
                var gregorianDate = getDateFromJulianDay(julianDay, false);
                var gregJDN = getJulianDayNumber(parsed.day, parsed.month, parsed.year);
                var rozdil = gregJDN - julianDay;

                result = '<strong>JuliÃ¡nskÃ½:</strong> ' + parsed.day + '.' + parsed.month + '.' + parsed.year + 
                        '<br><strong>GregoriÃ¡nskÃ½:</strong> ' + gregorianDate.day + '.' + gregorianDate.month + '.' + gregorianDate.year +
                        '<br><small>RozdÃ­l: ' + rozdil + ' dnÃ­</small>';
            }
            showResult(result);
        }, 300);
    }
    
    function calculateEaster() {
        var year = parseInt(document.getElementById('easterYear').value);
        
        if (!year || year < 1 || year > 9999) {
            showError("Zadejte platnÃ½ rok (1-9999)");
            return;
        }
        
        showLoading();
        setTimeout(function() {
            var easter = getEasterDate(year);
            var ashWednesday = addDays(easter, -46);
            var palmSunday = addDays(easter, -7);
            var goodFriday = addDays(easter, -2);
            var easterMonday = addDays(easter, 1);
            var whiteSunday = addDays(easter, 7);
            
            var result = '<strong>VelikonoÄnÃ­ svÃ¡tky ' + year + ':</strong><br>' +
                        '<small>PopeleÄnÃ­ stÅ™eda: ' + formatDate(ashWednesday) + '<br>' +
                        'KvÄ›tnÃ¡ nedÄ›le: ' + formatDate(palmSunday) + '<br>' +
                        'VelkÃ½ pÃ¡tek: ' + formatDate(goodFriday) + '<br>' +
                        '<strong>VelikonoÄnÃ­ nedÄ›le: ' + formatDate(easter) + '</strong><br>' +
                        'VelikonoÄnÃ­ pondÄ›lÃ­: ' + formatDate(easterMonday) + '<br>' +
                        'BÃ­lÃ¡ nedÄ›le: ' + formatDate(whiteSunday) + '</small>';
            
            showResult(result);
        }, 300);
    }
    
    function calculateMoonPhase() {
        var dateStr = document.getElementById('moonDate').value.trim();
        
        if (!dateStr) {
            showError("Zadejte datum");
            return;
        }
        
        var parsed = parseDate(dateStr);
        if (!parsed) {
            showError("NeplatnÃ½ formÃ¡t data");
            return;
        }
        
        showLoading();
        setTimeout(function() {
            var moonAge = getMoonAge(parsed.day, parsed.month, parsed.year);
            var phase = getMoonPhase(moonAge);
            var emoji = getMoonEmoji(moonAge);
            var illumination = Math.abs(Math.cos((moonAge / 29.53058867) * 2 * Math.PI - Math.PI)) * 100;
            
            var result = '<strong>' + parsed.day + '.' + parsed.month + '.' + parsed.year + '</strong><br>' +
                        emoji + ' <strong>' + phase + '</strong><br>' +
                        '<small>StÃ¡Å™Ã­ MÄ›sÃ­ce: ' + moonAge.toFixed(1) + ' dnÃ­<br>' +
                        'OsvÄ›tlenÃ­: ' + illumination.toFixed(1) + '%</small>';
            
            showResult(result);
        }, 300);
    }
    
    function calculateDateMath() {
        var mathType = document.getElementById('mathType').value;
        
        if (mathType === 'add') {
            var dateStr = document.getElementById('mathDate1').value.trim();
            var days = parseInt(document.getElementById('mathDays').value);
            
            if (!dateStr || isNaN(days)) {
                showError("Zadejte datum a poÄet dnÃ­");
                return;
            }
            
            var parsed = parseDate(dateStr);
            if (!parsed) {
                showError("NeplatnÃ½ formÃ¡t data");
                return;
            }
            
            showLoading();
            setTimeout(function() {
                var resultDate = addDays(parsed, days);
                var dayOfWeek = getDayOfWeekSimple(resultDate.day, resultDate.month, resultDate.year);
                
                var operation = days >= 0 ? 'pÅ™iÄtenÃ­' : 'odeÄtenÃ­';
                var result = '<strong>' + parsed.day + '.' + parsed.month + '.' + parsed.year + 
                           ' ' + (days >= 0 ? '+' : '') + days + ' dnÃ­:</strong><br>' +
                           '<strong>' + resultDate.day + '.' + resultDate.month + '.' + resultDate.year + '</strong><br>' +
                           '<small>' + dayOfWeek + '</small>';
                
                showResult(result);
            }, 300);
        } else {
            var dateStr1 = document.getElementById('mathDate2').value.trim();
            var dateStr2 = document.getElementById('mathDate3').value.trim();
            
            if (!dateStr1 || !dateStr2) {
                showError("Zadejte obÄ› data");
                return;
            }
            
            var parsed1 = parseDate(dateStr1);
            var parsed2 = parseDate(dateStr2);
            
            if (!parsed1 || !parsed2) {
                showError("NeplatnÃ½ formÃ¡t data");
                return;
            }
            
            showLoading();
            setTimeout(function() {
                var jd1 = getJulianDayNumber(parsed1.day, parsed1.month, parsed1.year);
                var jd2 = getJulianDayNumber(parsed2.day, parsed2.month, parsed2.year);
                var diff = Math.abs(jd2 - jd1);
                
                var years = Math.floor(diff / 365.25);
                var weeks = Math.floor(diff / 7);
                var remainingDays = diff % 7;
                
                var result = '<strong>RozdÃ­l mezi daty:</strong><br>' +
                           parsed1.day + '.' + parsed1.month + '.' + parsed1.year + ' a ' +
                           parsed2.day + '.' + parsed2.month + '.' + parsed2.year + '<br>' +
                           '<strong>' + diff + ' dnÃ­</strong><br>' +
                           '<small>' + weeks + ' tÃ½dnÅ¯ a ' + remainingDays + ' dnÃ­<br>' +
                           'PÅ™ibliÅ¾nÄ› ' + years + ' let</small>';
                
                showResult(result);
            }, 300);
        }
    }

    // Calculate sun events
    function calculateSunEventsFunc() {
        var dateStr = document.getElementById('sunEventsDate').value.trim();
        var latitude = parseFloat(document.getElementById('latitude').value);
        var longitude = parseFloat(document.getElementById('longitude').value);
        
        if (!dateStr) {
            showError("Zadejte datum");
            return;
        }
        
        if (isNaN(latitude) || isNaN(longitude)) {
            showError("Zadejte platnÃ© souÅ™adnice");
            return;
        }
        
        if (latitude < -90 || latitude > 90) {
            showError("ZemÄ›pisnÃ¡ Å¡Ã­Å™ka musÃ­ bÃ½t mezi -90 a 90 stupni");
            return;
        }
        
        if (longitude < -180 || longitude > 180) {
            showError("ZemÄ›pisnÃ¡ dÃ©lka musÃ­ bÃ½t mezi -180 a 180 stupni");
            return;
        }
        
        var parsed = parseDate(dateStr);
        if (!parsed) {
            showError("NeplatnÃ½ formÃ¡t data");
            return;
        }
        
        showLoading();
        setTimeout(function() {
            var sunEvents = calculateSunEvents(parsed.day, parsed.month, parsed.year, latitude, longitude);
            
            // Debug info for timezone calculation
            var debugTimezone = determineTimezone(longitude, parsed.month);
            var isDSTDebug = parsed.month > 3 && parsed.month < 10 || 
                           (parsed.month === 3) || 
                           (parsed.month === 10 && false); // October simplified to no DST
            
            var result = '<strong>SluneÄnÃ­ udÃ¡losti ' + parsed.day + '.' + parsed.month + '.' + parsed.year + '</strong><br>';
            
            if (sunEvents.polarNight) {
                result += '<strong>ğŸŒ‘ PolÃ¡rnÃ­ noc</strong><br>' + 
                         '<small>Na tÄ›chto souÅ™adnicÃ­ch slunce nevychÃ¡zÃ­<br>' +
                         'Deklinace Slunce: ' + sunEvents.declination + '</small>';
            } else if (sunEvents.polarDay) {
                result += '<strong>ğŸŒ PolÃ¡rnÃ­ den</strong><br>' +
                         '<small>Na tÄ›chto souÅ™adnicÃ­ch slunce nezapadÃ¡<br>' +
                         'Deklinace Slunce: ' + sunEvents.declination + '</small>';
            } else {
                result += '<strong>ğŸŒ… VÃ½chod slunce:</strong> ' + sunEvents.sunrise + '<br>' +
                         '<strong>ğŸŒ‡ ZÃ¡pad slunce:</strong> ' + sunEvents.sunset + '<br>' +
                         '<strong>â±ï¸ DÃ©lka dne:</strong> ' + sunEvents.dayLength + '<br>' +
                         '<small>ğŸ“ SouÅ™adnice: ' + latitude.toFixed(4) + 'Â°, ' + longitude.toFixed(4) + 'Â°<br>' +
                         'â˜€ï¸ Deklinace Slunce: ' + sunEvents.declination + '<br>';
                         
                if (sunEvents.eqTime) {
                    result += 'â° Rovnice Äasu: ' + sunEvents.eqTime + '<br>';
                }
                if (sunEvents.timezone) {
                    result += 'ğŸ• ÄŒasovÃ© pÃ¡smo: ' + sunEvents.timezone;
                    
                    // Add debug info for verification
                    var monthName = ['Leden','Ãšnor','BÅ™ezen','Duben','KvÄ›ten','ÄŒerven',
                                   'ÄŒervenec','Srpen','ZÃ¡Å™Ã­','Å˜Ã­jen','Listopad','Prosinec'][parsed.month-1];
                    var dstStatus = isDSTDebug ? 'LetnÃ­ Äas' : 'StandardnÃ­ Äas';
                    result += '<br>ğŸ“… ' + monthName + ' â†’ ' + dstStatus;
                }
                result += '</small>';
            }
            
            showResult(result);
        }, 300);
    }
        
    // Calculate planet positions
    function calculatePlanetPositionsFunc() {
        var dateStr = document.getElementById('planetDate').value.trim();
        
        if (!dateStr) {
            showError("Zadejte datum");
            return;
        }
        
        var parsed = parseDate(dateStr);
        if (!parsed) {
            showError("NeplatnÃ½ formÃ¡t data");
            return;
        }
        
        showLoading();
        setTimeout(function() {
            // Get time inputs
            var timeStr = document.getElementById('planetTime').value || "00:00";
            var timezone = parseInt(document.getElementById('planetTimezone').value) || 0;
            var timeParts = timeStr.split(':');
            var hour = parseInt(timeParts[0]) || 0;
            var minute = parseInt(timeParts[1]) || 0;

            var planets = getPlanetPositions(parsed.day, parsed.month, parsed.year, hour, minute, timezone);
                
             var result = '<strong>Pozice planet ' + parsed.day + '.' + parsed.month + '.' + parsed.year + '</strong><br>' +
                        '<small>ÄŒas: ' + timeStr + ' (UTC' + (timezone >= 0 ? '+' : '') + timezone + ')</small><br><br>';

            for (var i = 0; i < planets.length; i++) {
                var planet = planets[i];
                result += '<strong>' + planet.name + '</strong><br>' +
                         'ğŸ“ ' + planet.position + '<br>' +
                         'ğŸ“ Elongace: ' + planet.elongation + '<br>' +
                         'â­ SouhvÄ›zdÃ­: ' + planet.constellation + '<br>' +
                         'âœ¨ Jasnost: ' + planet.magnitude + '<br>' +
                         'ğŸ‘ï¸ ' + planet.visibility + '<br>' +
                         '<small>' + planet.type + '</small><br><br>';
            }
            showResult(result);
        }, 300);
    }
    
    // Calculate eclipses
    function calculateEclipsesFunc() {
        var year = parseInt(document.getElementById('eclipsesYear').value);
        
        if (!year || year < 1000 || year > 3000) {
            showError("Zadejte platnÃ½ rok (1000-3000)");
            return;
        }
        
        showLoading();
        setTimeout(function() {
            var eclipses = getEclipses(year);
            var currentYear = new Date().getFullYear();
            
            var result = '<strong>ZatmÄ›nÃ­ v roce ' + year + ':</strong><br>';
            
            if (eclipses.length === 0) {
                result += '<small>V tomto roce nebudou Å¾Ã¡dnÃ¡ vÃ½znamnÃ¡ zatmÄ›nÃ­ viditelnÃ¡.</small>';
            } else {
                result += '<small>';
                
                for (var i = 0; i < eclipses.length; i++) {
                    var eclipse = eclipses[i];
                    result += '<strong>' + eclipse.type + ' zatmÄ›nÃ­:</strong> ' + eclipse.date + '<br>';
                    result += 'Viditelnost: ' + eclipse.visibility + '<br>';
                    
                    if (eclipse.sarosInfo) {
                        result += '<em>' + eclipse.sarosInfo + '</em><br>';
                    }
                    if (eclipse.note) {
                        result += '<em>' + eclipse.note + '</em><br>';
                    }
                    
                    result += '<br>';
                }
                
                // Add accuracy note
                if (Math.abs(year - currentYear) <= 10) {
                    result += '<em>ğŸ“ PÅ™esnÃ¡ data pro roky blÃ­zkÃ© souÄasnosti</em>';
                } else if (Math.abs(year - currentYear) <= 50) {
                    result += '<em>ğŸ”¬ Aproximace pomocÃ­ Saros cyklÅ¯</em>';
                } else {
                    result += '<em>ğŸ“Š StatistickÃ¡ aproximace - ovÄ›Å™te v dalÅ¡Ã­ch zdrojÃ­ch</em>';
                }
                
                result += '</small>';
            }
            
            showResult(result);
        }, 300);
    }
        
    // Calculate sidereal time
    function calculateSiderealTimeFunc() {
        var dateStr = document.getElementById('siderealDate').value.trim();
        var timeStr = document.getElementById('siderealTime').value;
        var longitude = parseFloat(document.getElementById('siderealLongitude').value);
        var dstOffset = parseInt(document.getElementById('siderealDST').value) || 0;
        
        if (!dateStr || !timeStr) {
            showError("Zadejte datum a Äas");
            return;
        }
        
        if (isNaN(longitude)) {
            showError("Zadejte platnou zemÄ›pisnou dÃ©lku");
            return;
        }
        
        var parsed = parseDate(dateStr);
        if (!parsed) {
            showError("NeplatnÃ½ formÃ¡t data");
            return;
        }
        
        var timeParts = timeStr.split(':');
        var hour = parseInt(timeParts[0]);
        var minute = parseInt(timeParts[1]);
        
        showLoading();
        setTimeout(function() {
            var sidereal = getSiderealTime(parsed.day, parsed.month, parsed.year, hour, minute, longitude, dstOffset);
            
            var result = '<strong>HvÄ›zdnÃ½ Äas ' + parsed.day + '.' + parsed.month + '.' + parsed.year + '</strong><br>' +
                        '<strong>MÃ­stnÃ­ Äas:</strong> ' + hour + ':' + (minute < 10 ? '0' : '') + minute + ' (' + sidereal.timezone + ')<br>' +
                        '<strong>UTC Äas:</strong> ' + sidereal.utcTime + '<br>' +
                        '<strong>GreenwichskÃ½ hvÄ›zdnÃ½ Äas:</strong> ' + sidereal.gst + '<br>' +
                        '<strong>MÃ­stnÃ­ hvÄ›zdnÃ½ Äas:</strong> ' + sidereal.lst + '<br>' +
                        '<small>LST ve stupnÃ­ch: ' + sidereal.lstDegrees + '<br>' +
                        'ZemÄ›pisnÃ¡ dÃ©lka: ' + longitude.toFixed(4) + 'Â°<br>' +
                        'ÄŒasovÃ© pÃ¡smo: ' + Math.round(longitude / 15) + (dstOffset ? ' + letnÃ­ Äas' : '') + '</small>';
            
            showResult(result);
        }, 300);
    }

    // Universal safe tap/click handler
    function addSafeTap(selector, callback) {
        var items = document.querySelectorAll(selector);
        for (var i = 0; i < items.length; i++) {
            (function(item) {
                let touchMoved = false;
                item.addEventListener('touchstart', function(e) {
                    touchMoved = false;
                });
                item.addEventListener('touchmove', function(e) {
                    touchMoved = true;
                });
                item.addEventListener('touchend', function(e) {
                    if (!touchMoved) callback(item, e);
                });
                item.addEventListener('click', function(e) {
                    callback(item, e);
                });
            })(items[i]);
        }
    }

    // Application initialization
    function initializeApp() {
        try {
            // Initialize PWA functionality
            initPWA();
            
            // Set up enhanced connection monitoring and offline handling
            setupOfflineHandling();
            
            // PWA Install button handlers
            var installBtn = document.getElementById('installBtn');
            var dismissBtn = document.getElementById('dismissBtn');
            
            if (installBtn) {
                installBtn.addEventListener('click', handleInstall);
                installBtn.addEventListener('touchend', handleInstall);
            }
            
            if (dismissBtn) {
                dismissBtn.addEventListener('click', dismissInstall);
                dismissBtn.addEventListener('touchend', dismissInstall);
            }
            
            var savedTheme = getStoredTheme();
            if (savedTheme) {
                document.body.className = savedTheme;
            }
            
            // Menu button
            var menuButton = document.getElementById('menuButton');
            if (menuButton) {
                menuButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMenu();
                });
                menuButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMenu();
                });
            }
            
            // Menu items
            addSafeTap('#dayOfWeekMenu', function(item) {
                showCalculator('dayOfWeek');
            });
            
            addSafeTap('#calculatorsMenu', function(item, e) {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                toggleSubmenu('calculatorsSubmenu');
            });

            addSafeTap('#astronomyMenu', function(item, e) {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                toggleSubmenu('astronomySubmenu');
            });
            
            // Calculator menu items
            var calcItems = document.querySelectorAll('[data-calculator]');
            for (var i = 0; i < calcItems.length; i++) {
                (function(item) {
                    var calc = item.getAttribute('data-calculator');
                    let touchMoved = false;
                    item.addEventListener('touchstart', function(e) {
                        touchMoved = false;
                    });
                    item.addEventListener('touchmove', function(e) {
                        touchMoved = true;
                    });
                    item.addEventListener('touchend', function(e) {
                        if (!touchMoved) showCalculator(calc);
                    });
                    item.addEventListener('click', function() {
                        showCalculator(calc);
                    });
                })(calcItems[i]);
            }
            
            // Back buttons
            addSafeTap('[data-back]', function(item) {
                showCalculator('dayOfWeek');
            });
            
            // Version button
            addSafeTap('#versionButton', function(item) {
                showVersion();
            });
            
            // Theme items
            addSafeTap('.theme-item', function(item) {
                var theme = item.getAttribute('data-theme') || '';
                changeTheme(theme);
            });
            
            // Link items
            addSafeTap('[data-link]', function(item) {
                var link = item.getAttribute('data-link');
                openLink(link);
            });
            
            // Input focus tracking
            var inputs = document.querySelectorAll('input[type="text"], input[type="number"], input[type="time"]');
            for (var i = 0; i < inputs.length; i++) {
                (function(input) {
                    input.addEventListener('focus', function() {
                        activeInput = input;
                    });
                    input.addEventListener('input', clearDisplay);
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter' || e.keyCode === 13) {
                            e.preventDefault();
                            switch(currentCalculator) {
                                case 'dayOfWeek':
                                    calculateDayOfWeek();
                                    break;
                                case 'yearFinder':
                                    calculateYearFinder();
                                    break;
                                case 'calendarConverter':
                                    calculateConverter();
                                    break;
                                case 'easter':
                                    calculateEaster();
                                    break;
                                case 'moonPhase':
                                    calculateMoonPhase();
                                    break;
                                case 'dateMath':
                                    calculateDateMath();
                                    break;
                                case 'sunEvents':
                                    calculateSunEventsFunc();
                                    break;
                                case 'planetPositions':
                                    calculatePlanetPositionsFunc();
                                    break;
                                case 'eclipses':
                                    calculateEclipsesFunc();
                                    break;
                                case 'siderealTime':
                                    calculateSiderealTimeFunc();
                                    break;
                            }
                        }
                    });
                })(inputs[i]);
            }
            
            // Calculate buttons
            var calculateBtn = document.getElementById('calculateBtn');
            if (calculateBtn) {
                calculateBtn.addEventListener('click', calculateDayOfWeek);
                calculateBtn.addEventListener('touchend', calculateDayOfWeek);
            }
            
            var yearFinderBtn = document.getElementById('yearFinderBtn');
            if (yearFinderBtn) {
                yearFinderBtn.addEventListener('click', calculateYearFinder);
                yearFinderBtn.addEventListener('touchend', calculateYearFinder);
            }
            
            var converterBtn = document.getElementById('converterBtn');
            if (converterBtn) {
                converterBtn.addEventListener('click', calculateConverter);
                converterBtn.addEventListener('touchend', calculateConverter);
            }
            
            var easterBtn = document.getElementById('easterBtn');
            if (easterBtn) {
                easterBtn.addEventListener('click', calculateEaster);
                easterBtn.addEventListener('touchend', calculateEaster);
            }
            
            var moonBtn = document.getElementById('moonBtn');
            if (moonBtn) {
                moonBtn.addEventListener('click', calculateMoonPhase);
                moonBtn.addEventListener('touchend', calculateMoonPhase);
            }
            
            var dateMathBtn = document.getElementById('dateMathBtn');
            if (dateMathBtn) {
                dateMathBtn.addEventListener('click', calculateDateMath);
                dateMathBtn.addEventListener('touchend', calculateDateMath);
            }
            
            // Astronomy calculator buttons
            var sunEventsBtn = document.getElementById('sunEventsBtn');
            if (sunEventsBtn) {
                sunEventsBtn.addEventListener('click', calculateSunEventsFunc);
                sunEventsBtn.addEventListener('touchend', calculateSunEventsFunc);
            }
                
            var planetBtn = document.getElementById('planetBtn');
            if (planetBtn) {
                planetBtn.addEventListener('click', calculatePlanetPositionsFunc);
                planetBtn.addEventListener('touchend', calculatePlanetPositionsFunc);
            }
            
            var eclipsesBtn = document.getElementById('eclipsesBtn');
            if (eclipsesBtn) {
                eclipsesBtn.addEventListener('click', calculateEclipsesFunc);
                eclipsesBtn.addEventListener('touchend', calculateEclipsesFunc);
            }
            
            var siderealBtn = document.getElementById('siderealBtn');
            if (siderealBtn) {
                siderealBtn.addEventListener('click', calculateSiderealTimeFunc);
                siderealBtn.addEventListener('touchend', calculateSiderealTimeFunc);
            }
            
            // Math type selector
            var mathType = document.getElementById('mathType');
            if (mathType) {
                mathType.addEventListener('change', toggleMathOperation);
            }
            
            // Example items for day of week calculator
            var exampleItems = document.querySelectorAll('[data-date]');
            for (var i = 0; i < exampleItems.length; i++) {
                (function(item) {
                    var date = item.getAttribute('data-date');
                    let touchMoved = false;
                    item.addEventListener('touchstart', function(e) {
                        touchMoved = false;
                    });
                    item.addEventListener('touchmove', function(e) {
                        touchMoved = true;
                    });
                    item.addEventListener('touchend', function(e) {
                        if (!touchMoved) fillDate(date);
                    });
                    item.addEventListener('click', function() {
                        fillDate(date);
                    });
                })(exampleItems[i]);
            }
            
            // Close menu when clicking outside
            function closeMenuOutside(event) {
                var menuContainer = document.querySelector('.menu-container');
                var dropdown = document.getElementById('menuDropdown');
                
                if (menuContainer && dropdown && !menuContainer.contains(event.target) && isMenuOpen) {
                    dropdown.classList.remove('show');
                    isMenuOpen = false;
                }
            }
            
            document.addEventListener('click', closeMenuOutside);
            document.addEventListener('touchstart', closeMenuOutside);
            
            // Prevent double tap zoom
            var lastTouchEnd = 0;
            document.addEventListener('touchend', function(event) {
                var now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
            
            // Handle orientation change
            function handleOrientationChange() {
                setTimeout(function() {
                    var dropdown = document.getElementById('menuDropdown');
                    if (dropdown && isMenuOpen) {
                        dropdown.classList.remove('show');
                        setTimeout(function() {
                            dropdown.classList.add('show');
                        }, 50);
                    }
                }, 100);
            }
            
            if (window.addEventListener) {
                window.addEventListener('orientationchange', handleOrientationChange);
                window.addEventListener('resize', handleOrientationChange);
            }
            
            // Initialize current date for inputs
            var today = new Date();
            var todayStr = today.getDate() + '.' + (today.getMonth() + 1) + '.' + today.getFullYear();
            
            // Set default values for some inputs
            var sunEventsDate = document.getElementById('sunEventsDate');
            if (sunEventsDate && !sunEventsDate.value) {
                sunEventsDate.placeholder = todayStr;
            }
            
            var planetDate = document.getElementById('planetDate');
            if (planetDate && !planetDate.value) {
                planetDate.placeholder = todayStr;
            }
            
            var siderealDate = document.getElementById('siderealDate');
            if (siderealDate && !siderealDate.value) {
                siderealDate.placeholder = todayStr;
            }
            var siderealTime = document.getElementById('siderealTime');
            if (siderealTime && !siderealTime.value) {
                var currentHour = today.getHours();
                var currentMinute = today.getMinutes();
                siderealTime.value = (currentHour < 10 ? '0' : '') + currentHour + ':' + (currentMinute < 10 ? '0' : '') + currentMinute;
            }
            
            // Set default DST for current season with improved logic
            var siderealDST = document.getElementById('siderealDST');
            if (siderealDST) {
                var currentMonth = today.getMonth() + 1; // 1-12
                // European DST logic: April to September definitely DST, March/October depends on date
                var isDST = false;
                if (currentMonth > 3 && currentMonth < 10) {
                    isDST = true; // Definitely DST
                } else if (currentMonth === 3) {
                    // In March, assume DST after 25th (simplified)
                    isDST = today.getDate() >= 25;
                } else if (currentMonth === 10) {
                    // In October, assume DST before 25th (simplified)
                    isDST = today.getDate() < 25;
                }
                siderealDST.value = isDST ? "1" : "0";
            }
            
            // Register external service worker with smart offline behavior
            if ('serviceWorker' in navigator && 'caches' in window) {
                navigator.serviceWorker.register('./sw.js')
                    .then(function(registration) {
                        console.log('âœ… Service Worker registered successfully:', registration.scope);
                        
                        // Handle installation and updates
                        registration.addEventListener('updatefound', function() {
                            var newWorker = registration.installing;
                            console.log('ğŸ”„ New Service Worker installing...');
                            
                            newWorker.addEventListener('statechange', function() {
                                if (newWorker.state === 'installed') {
                                    if (navigator.serviceWorker.controller) {
                                        console.log('ğŸ†• New version available');
                                        showUpdateAvailable(true);
                                    } else {
                                        console.log('âœ… App cached for offline use');
                                        checkCacheStatus();
                                    }
                                }
                                if (newWorker.state === 'activated') {
                                    console.log('âœ… Service Worker activated');
                                    checkCacheStatus();
                                }
                            });
                        });
                        
                        // Check immediate status
                        if (registration.active && navigator.serviceWorker.controller) {
                            console.log('âœ… Service Worker already active');
                            checkCacheStatus();
                        }
                        
                        if (registration.waiting) {
                            showUpdateAvailable(true);
                        }
                    })
                    .catch(function(error) {
                        console.log('âŒ Service Worker registration failed:', error);
                        showOfflineFallback();
                    });
                
                // Listen for controller change
                navigator.serviceWorker.addEventListener('controllerchange', function() {
                    console.log('ğŸ”„ Service Worker controller changed');
                    checkCacheStatus();
                });
                
                // Listen for messages from SW
                navigator.serviceWorker.addEventListener('message', function(event) {
                    if (event.data) {
                        switch(event.data.type) {
                            case 'CACHE_STATUS':
                                if (event.data.hasCache) {
                                    showOfflineReady();
                                }
                                break;
                            case 'UPDATE_AVAILABLE':
                                console.log('ğŸ†• Background update detected');
                                showUpdateAvailable(false); // Non-intrusive
                                break;
                            case 'CONTENT_UPDATED':
                                console.log('âœ… Content updated in background');
                                break;
                        }
                    }
                });
                
            } else {
                console.log('âŒ Service Workers not supported');
                showOfflineFallback();
            }
            
            // Check cache status and show appropriate notification
            function checkCacheStatus() {
                setTimeout(function() {
                    if ('caches' in window) {
                        caches.has('calendar-calculator-v1.4')
                            .then(function(hasCache) {
                                if (hasCache) {
                                    caches.match('./')
                                        .then(function(cachedResponse) {
                                            if (cachedResponse) {
                                                console.log('âœ… Cache verified - smart offline mode active');
                                                showOfflineReady();
                                            } else {
                                                console.log('âš ï¸ Cache exists but content not found');
                                                showCacheBuilding();
                                            }
                                        });
                                } else {
                                    console.log('âš ï¸ No cache found');
                                    showCacheBuilding();
                                }
                            })
                            .catch(function(error) {
                                console.log('âŒ Cache check failed:', error);
                                showOfflineFallback();
                            });
                    }
                }, 1500);
            }
            
            // Show offline ready notification - enhanced
            function showOfflineReady() {
                var statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    if (navigator.onLine) {
                        statusElement.textContent = 'âœ… Smart mode - okamÅ¾itÃ© naÄÃ­tÃ¡nÃ­ + background aktualizace';
                        statusElement.className = 'connection-status online';
                        setTimeout(function() {
                            statusElement.classList.remove('online');
                        }, 6000);
                    } else {
                        statusElement.textContent = 'ğŸ“± Offline - vÅ¡e funguje z cache';
                        statusElement.className = 'connection-status offline';
                    }
                }
            }
            
            // Show cache building notification
            function showCacheBuilding() {
                var statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    statusElement.textContent = 'â³ PÅ™Ã­prava smart cache...';
                    statusElement.className = 'connection-status offline';
                    setTimeout(checkCacheStatus, 3000);
                }
            }
            
            // Show update available notification - non-intrusive or intrusive
            function showUpdateAvailable(intrusive) {
                var statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    if (intrusive) {
                        // Major update - show prominently
                        statusElement.textContent = 'ğŸ”„ NovÃ¡ verze - kliknÄ›te pro aktualizaci';
                        statusElement.className = 'connection-status online';
                        statusElement.style.cursor = 'pointer';
                        statusElement.onclick = function() {
                            applyUpdate();
                        };
                    } else {
                        // Background update - subtle notification
                        statusElement.textContent = 'ğŸ”„ AktualizovÃ¡no na pozadÃ­ - pro aktivaci obnovte strÃ¡nku';
                        statusElement.className = 'connection-status online';
                        statusElement.style.cursor = 'pointer';
                        statusElement.onclick = function() {
                            if (confirm('NaÄÃ­st aktualizovanou verzi aplikace?')) {
                                window.location.reload();
                            }
                        };
                        
                        // Auto-hide after 8 seconds
                        setTimeout(function() {
                            if (statusElement.textContent.includes('AktualizovÃ¡no na pozadÃ­')) {
                                statusElement.classList.remove('online');
                                statusElement.style.cursor = 'default';
                                statusElement.onclick = null;
                            }
                        }, 8000);
                    }
                }
            }
            
            // Apply update function
            function applyUpdate() {
                var statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    statusElement.textContent = 'â³ Aplikuje se aktualizace...';
                    statusElement.className = 'connection-status offline';
                    statusElement.style.cursor = 'default';
                    statusElement.onclick = null;
                }
                
                if (navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({type: 'SKIP_WAITING'});
                }
                
                setTimeout(function() {
                    window.location.reload();
                }, 500);
            }
            
            // Enhanced connection monitoring
            function setupSmartConnectionMonitoring() {
                function updateConnectionDisplay() {
                    var statusElement = document.getElementById('connectionStatus');
                    if (!statusElement) return;
                    
                    if (navigator.onLine) {
                        // Don't show online status if we're already showing other info
                        if (!statusElement.textContent || 
                            statusElement.textContent.includes('Offline')) {
                            statusElement.textContent = 'ğŸŒ Online - background aktualizace aktivnÃ­';
                            statusElement.className = 'connection-status online';
                            setTimeout(function() {
                                statusElement.classList.remove('online');
                            }, 3000);
                        }
                    } else {
                        statusElement.textContent = 'ğŸ“± Offline - vÅ¡e funguje z cache';
                        statusElement.className = 'connection-status offline';
                    }
                }
                
                window.addEventListener('online', updateConnectionDisplay);
                window.addEventListener('offline', updateConnectionDisplay);
            }
            
            // Manual update check function
            function checkForUpdates() {
                if (navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({type: 'CHECK_UPDATES'});
                    
                    var statusElement = document.getElementById('connectionStatus');
                    if (statusElement) {
                        statusElement.textContent = 'ğŸ” Kontrola aktualizacÃ­...';
                        statusElement.className = 'connection-status online';
                        
                        setTimeout(function() {
                            statusElement.classList.remove('online');
                        }, 2000);
                    }
                }
            }
            
            // Initialize smart connection monitoring
            setupSmartConnectionMonitoring();
            
            // Export debug functions to global scope for testing
            if (typeof window !== 'undefined') {
                window.PWADebug = {
                    showInstallPrompt: function() {
                        showInstallPrompt();
                        console.log('ğŸ”§ DEBUG: Install prompt forced');
                    },
                    clearInstallData: function() {
                        if (hasLocalStorage) {
                            try {
                                localStorage.removeItem('pwa-install-dismissed');
                                localStorage.removeItem('pwa-installed');
                                console.log('ğŸ”§ DEBUG: Install data cleared');
                            } catch(e) {
                                console.log('ğŸ”§ DEBUG: Failed to clear install data');
                            }
                        }
                    },
                    checkCacheStatus: function() {
                        checkCacheStatus();
                        console.log('ğŸ”§ DEBUG: Cache status check triggered');
                    },
                    forceInstallPrompt: function() {
                        var installPrompt = document.getElementById('installPrompt');
                        if (installPrompt) {
                            installPrompt.classList.add('show');
                            console.log('ğŸ”§ DEBUG: Install prompt UI forced visible');
                        } else {
                            console.log('ğŸ”§ DEBUG: Install prompt element not found');
                        }
                    },
                    hideInstallPrompt: function() {
                        var installPrompt = document.getElementById('installPrompt');
                        if (installPrompt) {
                            installPrompt.classList.remove('show');
                            console.log('ğŸ”§ DEBUG: Install prompt hidden');
                        }
                    },
                    getInstallState: function() {
                        var state = {
                            isInstalled: isInstalled,
                            hasDeferred: !!deferredPrompt,
                            dismissed: hasLocalStorage ? localStorage.getItem('pwa-install-dismissed') : null,
                            swSupported: 'serviceWorker' in navigator,
                            standalone: window.matchMedia('(display-mode: standalone)').matches,
                            https: location.protocol === 'https:',
                            localhost: location.hostname === 'localhost' || location.hostname === '127.0.0.1'
                        };
                        console.table(state);
                        
                        // Additional diagnostics
                        console.log('ğŸ” PWA Install Diagnostics:');
                        
                        // Check manifest
                        var manifestLink = document.querySelector('link[rel="manifest"]');
                        console.log('ğŸ“‹ Manifest link:', manifestLink ? manifestLink.href : 'NOT FOUND');
                        
                        // Check SW registration
                        if ('serviceWorker' in navigator) {
                            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                                console.log('âš™ï¸ Service Workers:', registrations.length + ' registered');
                                registrations.forEach(function(reg, i) {
                                    console.log('  SW' + i + ':', reg.scope, reg.active ? 'ACTIVE' : 'INACTIVE');
                                });
                            });
                        }
                        
                        // Check security context
                        console.log('ğŸ”’ Secure context:', window.isSecureContext);
                        console.log('ğŸŒ Protocol:', location.protocol);
                        
                        // PWA install criteria
                        console.log('ğŸ“± PWA Install Criteria:');
                        console.log('  âœ… HTTPS or localhost:', state.https || state.localhost);
                        console.log('  âœ… Service Worker:', state.swSupported);
                        console.log('  âœ… Manifest:', !!manifestLink);
                        console.log('  â“ User engagement: (cannot check programmatically)');
                        
                        return state;
                    },
                    checkPWACriteria: function() {
                        console.log('ğŸ”¬ Checking PWA Installation Criteria...');
                        
                        var checks = {
                            https: location.protocol === 'https:' || location.hostname === 'localhost',
                            manifest: !!document.querySelector('link[rel="manifest"]'),
                            serviceWorker: 'serviceWorker' in navigator,
                            secureContext: window.isSecureContext
                        };
                        
                        console.log('PWA Criteria Check:');
                        Object.keys(checks).forEach(function(key) {
                            console.log('  ' + (checks[key] ? 'âœ…' : 'âŒ') + ' ' + key + ':', checks[key]);
                        });
                        
                        if (!checks.https) {
                            console.log('ğŸš¨ PROBLEM: PWA requires HTTPS (except localhost)');
                        }
                        if (!checks.manifest) {
                            console.log('ğŸš¨ PROBLEM: manifest.json link not found');
                        }
                        if (!checks.serviceWorker) {
                            console.log('ğŸš¨ PROBLEM: Service Workers not supported');
                        }
                        
                        // Try to fetch manifest
                        var manifestLink = document.querySelector('link[rel="manifest"]');
                        if (manifestLink) {
                            fetch(manifestLink.href)
                                .then(function(response) {
                                    if (response.ok) {
                                        return response.json();
                                    }
                                    throw new Error('Manifest fetch failed: ' + response.status);
                                })
                                .then(function(manifest) {
                                    console.log('ğŸ“‹ Manifest loaded successfully:', manifest);
                                })
                                .catch(function(error) {
                                    console.log('ğŸš¨ Manifest load error:', error);
                                });
                        }
                        
                        return checks;
                    }
                };
                
                console.log('ğŸ”§ PWA Debug functions available:');
                console.log('â€¢ PWADebug.showInstallPrompt() - zobrazÃ­ install prompt');
                console.log('â€¢ PWADebug.clearInstallData() - vymaÅ¾e install data');
                console.log('â€¢ PWADebug.forceInstallPrompt() - vynutÃ­ UI prompt');
                console.log('â€¢ PWADebug.hideInstallPrompt() - skryje prompt');
                console.log('â€¢ PWADebug.getInstallState() - zobrazÃ­ stav instalace');
                console.log('â€¢ PWADebug.checkCacheStatus() - zkontroluje cache');
            }
            
            // Fallback for unsupported browsers
            function showOfflineFallback() {
                setupFallbackCache();
                var statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    statusElement.textContent = 'âš ï¸ ZÃ¡kladnÃ­ cache (prohlÃ­Å¾eÄ nepodporuje PWA)';
                    statusElement.className = 'connection-status offline';
                }
            }
            
            // Enhanced fallback cache system
            function setupFallbackCache() {
                console.log('ğŸ“¦ Setting up enhanced fallback cache');
                
                try {
                    if (hasLocalStorage) {
                        var appData = {
                            html: document.documentElement.outerHTML,
                            timestamp: Date.now(),
                            version: 'v1.4-fallback'
                        };
                        
                        localStorage.setItem('offline-calendar-app', JSON.stringify(appData));
                        console.log('âœ… Enhanced fallback cache created');
                    }
                } catch (e) {
                    console.log('âŒ Fallback cache failed:', e);
                }
                
                window.addEventListener('beforeunload', function() {
                    try {
                        if (hasLocalStorage && navigator.onLine) {
                            var appData = {
                                html: document.documentElement.outerHTML,
                                timestamp: Date.now(),
                                version: 'v1.4-fallback'
                            };
                            localStorage.setItem('offline-calendar-app', JSON.stringify(appData));
                        }
                    } catch (e) {}
                });
            }
            
        } catch (error) {
            console.log('Initialization error:', error);
        }
    }
    
    // Initialize app when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }
    
})();
</script>
</body>
</html>